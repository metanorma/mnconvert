= Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)
:doctype: internet-draft
:abbrev: TURN
:name: draft-ietf-tram-turnbis-29
:status: standard
:intended-series: standard
:submission-type: IETF
:ipr: trust200902
:obsoletes: 5766, 6156
:instance: https://dx.doi.org/10.17487/rfc8656
:instance: urn:issn:2070-1721
:revdate: 2020-01-01T00:00:00Z
:area: Transport
:workgroup: TRAM WG
:keyword: NAT, TURN, STUN, ICE
:xml-lang: en
:consensus: true
:index-include: true
:sort-refs: true
:sym-refs: true
:toc-include: true
:toc-depth: 3
:show-on-front-page: true
:fullname: Tirumaleswar Reddy
:initials: T.
:surname: Reddy
:role: editor
:affiliation: McAfee, Inc.
:affiliation_abbrev: McAfee
:email: kondtir@gmail.com
:address: Embassy Golf Link Business Park + \
Bangalore + \
Karnataka + \
India + \
560071
:fullname_2: Alan Johnston
:initials_2: A.
:surname_2: Johnston
:role_2: editor
:affiliation_2: Villanova University
:email_2: alan.b.johnston@gmail.com
:address_2: Villanova + \
PA + \
United States of America
:fullname_3: Philip Matthews
:initials_3: P.
:surname_3: Matthews
:affiliation_3: Alcatel-Lucent
:email_3: philip_matthews@magma.ca
:address_3: 600 March Road + \
Ottawa + \
Ontario + \
Canada
:fullname_4: Jonathan Rosenberg
:initials_4: J.
:surname_4: Rosenberg
:affiliation_4: jdrosen.net
:email_4: jdrosen@jdrosen.net
:contributor-uri_4: http://www.jdrosen.net
:address_4: Edison + \
NJ + \
United States of America

[abstract]
== Abstract
If a host is located behind a NAT, it can be impossible for that host to communicate directly with other hosts (peers) in certain situations. In these situations, it is necessary for the host to use the services of an intermediate node that acts as a communication relay. This specification defines a protocol, called "Traversal Using Relays around NAT" (TURN), that allows the host to control the operation of the relay and to exchange packets with its peers using the relay. TURN differs from other relay control protocols in that it allows a client to communicate with multiple peers using a single relay address.

The TURN protocol was designed to be used as part of the Interactive Connectivity Establishment (ICE) approach to NAT traversal, though it can also be used without ICE.

This document obsoletes RFCs 5766 and 6156.

[[status-of-memo]]
[numbered=false,removeInRFC=false,toc=exclude]
== Status of This Memo

This is an Internet Standards Track document.

This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.

Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at  https://www.rfc-editor.org/info/rfc8656.

[[copyright]]
[numbered=false,removeInRFC=false,toc=exclude]
== Copyright Notice

Copyright (c) 2020 IETF Trust and the persons identified as the document authors. All rights reserved.

This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents ( https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.

[[toc]]
[numbered=false,removeInRFC=false,toc=exclude]
== Table of Contents

[nobullet=true,spacing=compact]
* <<section-1,format=counter>>.  <<name-introduction,format=title: Introduction>>
* <<section-2,format=counter>>.  <<name-terminology,format=title: Terminology>>
* <<section-3,format=counter>>.  <<name-overview-of-operation,format=title: Overview of Operation>>
[nobullet=true,spacing=compact]
** <<section-3.1,format=counter>>.  <<name-transports,format=title: Transports>>
** <<section-3.2,format=counter>>.  <<name-allocations,format=title: Allocations>>
** <<section-3.3,format=counter>>.  <<name-permissions,format=title: Permissions>>
** <<section-3.4,format=counter>>.  <<name-send-mechanism,format=title: Send Mechanism>>
** <<section-3.5,format=counter>>.  <<name-channels,format=title: Channels>>
** <<section-3.6,format=counter>>.  <<name-unprivileged-turn-servers,format=title: Unprivileged TURN Servers>>
** <<section-3.7,format=counter>>.  <<name-avoiding-ip-fragmentation,format=title: Avoiding IP Fragmentation>>
** <<section-3.8,format=counter>>.  <<name-rtp-support,format=title: RTP Support>>
** <<section-3.9,format=counter>>.  <<name-happy-eyeballs-for-turn,format=title: Happy Eyeballs for TURN>>
* <<section-4,format=counter>>.  <<name-discovery-of-turn-server,format=title: Discovery of TURN Server>>
[nobullet=true,spacing=compact]
** <<section-4.1,format=counter>>.  <<name-turn-uri-scheme-semantics,format=title: TURN URI Scheme Semantics>>
* <<section-5,format=counter>>.  <<name-general-behavior,format=title: General Behavior>>
* <<section-6,format=counter>>.  <<name-allocations-2,format=title: Allocations>>
* <<section-7,format=counter>>.  <<name-creating-an-allocation,format=title: Creating an Allocation>>
[nobullet=true,spacing=compact]
** <<section-7.1,format=counter>>.  <<name-sending-an-allocate-request,format=title: Sending an Allocate Request>>
** <<section-7.2,format=counter>>.  <<name-receiving-an-allocate-reque,format=title: Receiving an Allocate Request>>
** <<section-7.3,format=counter>>.  <<name-receiving-an-allocate-succe,format=title: Receiving an Allocate Success Response>>
** <<section-7.4,format=counter>>.  <<name-receiving-an-allocate-error,format=title: Receiving an Allocate Error Response>>
* <<section-8,format=counter>>.  <<name-refreshing-an-allocation,format=title: Refreshing an Allocation>>
[nobullet=true,spacing=compact]
** <<section-8.1,format=counter>>.  <<name-sending-a-refresh-request,format=title: Sending a Refresh Request>>
** <<section-8.2,format=counter>>.  <<name-receiving-a-refresh-request,format=title: Receiving a Refresh Request>>
** <<section-8.3,format=counter>>.  <<name-receiving-a-refresh-respons,format=title: Receiving a Refresh Response>>
* <<section-9,format=counter>>.  <<name-permissions-2,format=title: Permissions>>
* <<section-10,format=counter>>. <<name-createpermission,format=title: CreatePermission>>
[nobullet=true,spacing=compact]
** <<section-10.1,format=counter>>.  <<name-forming-a-createpermission-,format=title: Forming a CreatePermission Request>>
** <<section-10.2,format=counter>>.  <<name-receiving-a-createpermissio,format=title: Receiving a CreatePermission Request>>
** <<section-10.3,format=counter>>.  <<name-receiving-a-createpermission,format=title: Receiving a CreatePermission Response>>
* <<section-11,format=counter>>. <<name-send-and-data-methods,format=title: Send and Data Methods>>
[nobullet=true,spacing=compact]
** <<section-11.1,format=counter>>.  <<name-forming-a-send-indication,format=title: Forming a Send Indication>>
** <<section-11.2,format=counter>>.  <<name-receiving-a-send-indication,format=title: Receiving a Send Indication>>
** <<section-11.3,format=counter>>.  <<name-receiving-a-udp-datagram,format=title: Receiving a UDP Datagram>>
** <<section-11.4,format=counter>>.  <<name-receiving-a-data-indication,format=title: Receiving a Data Indication>>
** <<section-11.5,format=counter>>.  <<name-receiving-an-icmp-packet,format=title: Receiving an ICMP Packet>>
** <<section-11.6,format=counter>>.  <<name-receiving-a-data-indication-,format=title: Receiving a Data Indication with an ICMP Attribute>>
* <<section-12,format=counter>>. <<name-channels-2,format=title: Channels>>
[nobullet=true,spacing=compact]
** <<section-12.1,format=counter>>.  <<name-sending-a-channelbind-reque,format=title: Sending a ChannelBind Request>>
** <<section-12.2,format=counter>>.  <<name-receiving-a-channelbind-req,format=title: Receiving a ChannelBind Request>>
** <<section-12.3,format=counter>>.  <<name-receiving-a-channelbind-res,format=title: Receiving a ChannelBind Response>>
** <<section-12.4,format=counter>>.  <<name-the-channeldata-message,format=title: The ChannelData Message>>
** <<section-12.5,format=counter>>.  <<name-sending-a-channeldata-messa,format=title: Sending a ChannelData Message>>
** <<section-12.6,format=counter>>.  <<name-receiving-a-channeldata-mes,format=title: Receiving a ChannelData Message>>
** <<section-12.7,format=counter>>.  <<name-relaying-data-from-the-peer,format=title: Relaying Data from the Peer>>
* <<section-13,format=counter>>. <<name-packet-translations,format=title: Packet Translations>>
[nobullet=true,spacing=compact]
** <<section-13.1,format=counter>>.  <<name-ipv4-to-ipv6-translations,format=title: IPv4-to-IPv6 Translations>>
** <<section-13.2,format=counter>>.  <<name-ipv6-to-ipv6-translations,format=title: IPv6-to-IPv6 Translations>>
** <<section-13.3,format=counter>>.  <<name-ipv6-to-ipv4-translations,format=title: IPv6-to-IPv4 Translations>>
* <<section-14,format=counter>>. <<name-udp-to-udp-relay,format=title: UDP-to-UDP Relay>>
* <<section-15,format=counter>>. <<name-tcp-to-udp-relay,format=title: TCP-to-UDP Relay>>
* <<section-16,format=counter>>. <<name-udp-to-tcp-relay,format=title: UDP-to-TCP Relay>>
* <<section-17,format=counter>>. <<name-stun-methods,format=title: STUN Methods>>
* <<section-18,format=counter>>. <<name-stun-attributes,format=title: STUN Attributes>>
[nobullet=true,spacing=compact]
** <<section-18.1,format=counter>>.  <<name-channel-number,format=title: CHANNEL-NUMBER>>
** <<section-18.2,format=counter>>.  <<name-lifetime,format=title: LIFETIME>>
** <<section-18.3,format=counter>>.  <<name-xor-peer-address,format=title: XOR-PEER-ADDRESS>>
** <<section-18.4,format=counter>>.  <<name-data,format=title: DATA>>
** <<section-18.5,format=counter>>.  <<name-xor-relayed-address,format=title: XOR-RELAYED-ADDRESS>>
** <<section-18.6,format=counter>>.  <<name-requested-address-family,format=title: REQUESTED-ADDRESS-FAMILY>>
** <<section-18.7,format=counter>>.  <<name-even-port,format=title: EVEN-PORT>>
** <<section-18.8,format=counter>>.  <<name-requested-transport,format=title: REQUESTED-TRANSPORT>>
** <<section-18.9,format=counter>>.  <<name-dont-fragment,format=title: DONT-FRAGMENT>>
** <<section-18.10,format=counter>>. <<name-reservation-token,format=title: RESERVATION-TOKEN>>
** <<section-18.11,format=counter>>. <<name-additional-address-family,format=title: ADDITIONAL-ADDRESS-FAMILY>>
** <<section-18.12,format=counter>>. <<name-address-error-code,format=title: ADDRESS-ERROR-CODE>>
** <<section-18.13,format=counter>>. <<name-icmp,format=title: ICMP>>
* <<section-19,format=counter>>. <<name-stun-error-response-codes,format=title: STUN Error Response Codes>>
* <<section-20,format=counter>>. <<name-detailed-example,format=title: Detailed Example>>
* <<section-21,format=counter>>. <<name-security-considerations,format=title: Security Considerations>>
[nobullet=true,spacing=compact]
** <<section-21.1,format=counter>>.  <<name-outsider-attacks,format=title: Outsider Attacks>>
[nobullet=true,spacing=compact]
*** <<section-21.1.1,format=counter>>.  <<name-obtaining-unauthorized-allo,format=title: Obtaining Unauthorized Allocations>>
*** <<section-21.1.2,format=counter>>.  <<name-offline-dictionary-attacks,format=title: Offline Dictionary Attacks>>
*** <<section-21.1.3,format=counter>>.  <<name-faked-refreshes-and-permiss,format=title: Faked Refreshes and Permissions>>
*** <<section-21.1.4,format=counter>>.  <<name-fake-data,format=title: Fake Data>>
*** <<section-21.1.5,format=counter>>.  <<name-impersonating-a-server,format=title: Impersonating a Server>>
*** <<section-21.1.6,format=counter>>.  <<name-eavesdropping-traffic,format=title: Eavesdropping Traffic>>
*** <<section-21.1.7,format=counter>>.  <<name-turn-loop-attack,format=title: TURN Loop Attack>>
** <<section-21.2,format=counter>>.  <<name-firewall-considerations,format=title: Firewall Considerations>>
[nobullet=true,spacing=compact]
*** <<section-21.2.1,format=counter>>.  <<name-faked-permissions,format=title: Faked Permissions>>
*** <<section-21.2.2,format=counter>>.  <<name-blacklisted-ip-addresses,format=title: Blacklisted IP Addresses>>
*** <<section-21.2.3,format=counter>>.  <<name-running-servers-on-well-kno,format=title: Running Servers on Well-Known Ports>>
** <<section-21.3,format=counter>>.  <<name-insider-attacks,format=title: Insider Attacks>>
[nobullet=true,spacing=compact]
*** <<section-21.3.1,format=counter>>.  <<name-dos-against-turn-server,format=title: DoS against TURN Server>>
*** <<section-21.3.2,format=counter>>.  <<name-anonymous-relaying-of-malic,format=title: Anonymous Relaying of Malicious Traffic>>
*** <<section-21.3.3,format=counter>>.  <<name-manipulating-other-allocati,format=title: Manipulating Other Allocations>>
** <<section-21.4,format=counter>>.  <<name-tunnel-amplification-attack,format=title: Tunnel Amplification Attack>>
** <<section-21.5,format=counter>>.  <<name-other-considerations,format=title: Other Considerations>>
* <<section-22,format=counter>>. <<name-iana-considerations,format=title: IANA Considerations>>
* <<section-23,format=counter>>. <<name-iab-considerations,format=title: IAB Considerations>>
* <<section-24,format=counter>>. <<name-changes-since-rfc-5766,format=title: Changes since RFC 5766>>
* <<section-25,format=counter>>. <<name-updates-to-rfc-6156,format=title: Updates to RFC 6156>>
* <<section-26,format=counter>>. <<name-references,format=title: References>>
[nobullet=true,spacing=compact]
** <<section-26.1,format=counter>>.  <<name-normative-references,format=title: Normative References>>
** <<section-26.2,format=counter>>.  <<name-informative-references,format=title: Informative References>>
* <<section-appendix.a,format=none>><<name-acknowledgements,format=title: Acknowledgements>>
* <<section-appendix.b,format=none>><<name-authors-addresses,format=title: Authors' Addresses>>

[numbered=true,removeInRFC=false,toc=include]
== Introduction

A host behind a NAT may wish to exchange packets with other hosts, some of which may also be behind NATs. To do this, the hosts involved can use "hole punching" techniques (see <<RFC5128,format=default>>) in an attempt to discover a direct communication path; that is, a communication path that goes from one host to another through intervening NATs and routers but does not traverse any relays.

As described in <<RFC5128,format=default>> and <<RFC4787,format=default>>, hole punching techniques will fail if both hosts are behind NATs that are not well behaved. For example, if both hosts are behind NATs that have a mapping behavior of "address-dependent mapping" or "address- and port-dependent mapping" (see <<RFC4787,format=default>>), then hole punching techniques generally fail.

When a direct communication path cannot be found, it is necessary to use the services of an intermediate host that acts as a relay for the packets. This relay typically sits in the public Internet and relays packets between two hosts that both sit behind NATs.

In many enterprise networks, direct UDP transmissions are not permitted between clients on the internal networks and external IP addresses. To permit media sessions in such a situation to use UDP and avoid forcing them through TCP, an Enterprise Firewall can be configured to allow UDP traffic relayed through an Enterprise relay server. WebRTC requires support for this scenario (see <<RFC7478,format=default>>). Some users of SIP or WebRTC want IP location privacy from the remote peer. In this scenario, the client can select a relay server offering IP location privacy and only convey the relayed candidates to the peer for ICE connectivity checks (see <<I-D.ietf-rtcweb-security,format=default: SEC-WEBRTC>>).

This specification defines a protocol, called "TURN", that allows a host behind a NAT (called the "TURN client") to request that another host (called the "TURN server") act as a relay. The client can arrange for the server to relay packets to and from certain other hosts (called "peers"), and the client can control aspects of how the relaying is done. The client does this by obtaining an IP address and port on the server, called the "relayed transport address". When a peer sends a packet to the relayed transport address, the server relays the transport protocol data from the packet to the client. The data encapsulated within a message header that allows the client to know the peer from which the transport protocol data was relayed by the server. If the server receives an ICMP error packet, the server also relays certain Layer 3 and 4 header fields from the ICMP header to the client. When the client sends a message to the server, the server identifies the remote peer from the message header and relays the message data to the intended peer.

A client using TURN must have some way to communicate the relayed transport address to its peers and to learn each peer's IP address and port (more precisely, each peer's server-reflexive transport address; see <<sec-overview,format=default>>). How this is done is out of the scope of the TURN protocol. One way this might be done is for the client and peers to exchange email messages. Another way is for the client and its peers to use a special-purpose "introduction" or "rendezvous" protocol (see <<RFC5128,format=default>> for more details).

If TURN is used with ICE <<RFC8445,format=default>>, then the relayed transport address and the IP addresses and ports of the peers are included in the ICE candidate information that the rendezvous protocol must carry. For example, if TURN and ICE are used as part of a multimedia solution using SIP <<RFC3261,format=default>>, then SIP serves the role of the rendezvous protocol, carrying the ICE candidate information inside the body of SIP messages <<I-D.ietf-mmusic-ice-sip-sdp,format=default: SDP-ICE>>. If TURN and ICE are used with some other rendezvous protocol, then ICE provides guidance on the services the rendezvous protocol must perform.

Though the use of a TURN server to enable communication between two hosts behind NATs is very likely to work, it comes at a high cost to the provider of the TURN server since the server typically needs a high-bandwidth connection to the Internet. As a consequence, it is best to use a TURN server only when a direct communication path cannot be found. When the client and a peer use ICE to determine the communication path, ICE will use hole punching techniques to search for a direct path first and only use a TURN server when a direct path cannot be found.

TURN was originally invented to support multimedia sessions signaled using SIP. Since SIP supports forking, TURN supports multiple peers per relayed transport address; a feature not supported by other approaches (e.g., SOCKS <<RFC1928,format=default>>). However, care has been taken to make sure that TURN is suitable for other types of applications.

TURN was designed as one piece in the larger ICE approach to NAT traversal. Implementors of TURN are urged to investigate ICE and seriously consider using it for their application. However, it is possible to use TURN without ICE.

TURN is an extension to the Session Traversal Utilities for NAT (STUN) protocol <<RFC8489,format=default>>. Most, though not all, TURN messages are STUN-formatted messages. A reader of this document should be familiar with STUN.

The TURN specification was originally published as <<RFC5766,format=default>>, which was updated by <<RFC6156,format=default>> to add IPv6 support. This document supersedes and obsoletes both <<RFC5766,format=default>> and <<RFC6156,format=default>>.

[numbered=true,removeInRFC=false,toc=include]
== Terminology

The key words "[bcp14]#MUST#", "[bcp14]#MUST NOT#", "[bcp14]#REQUIRED#", "[bcp14]#SHALL#", "[bcp14]#SHALL NOT#", "[bcp14]#SHOULD#", "[bcp14]#SHOULD NOT#", "[bcp14]#RECOMMENDED#", "[bcp14]#NOT RECOMMENDED#", "[bcp14]#MAY#", and "[bcp14]#OPTIONAL#" in this document are to be interpreted as described in BCP 14 <<RFC2119,format=default>> <<RFC8174,format=default>> when, and only when, they appear in all capitals, as shown here.

Readers are expected to be familiar with <<RFC8489,format=default>> and the terms defined there.

The following terms are used in this document:

[newline=true,spacing=normal]
TURN::: The protocol spoken between a TURN client and a TURN server. It is an extension to the STUN protocol <<RFC8489,format=default>>. The protocol allows a client to allocate and use a relayed transport address.
TURN client::: A STUN client that implements this specification.
TURN server::: A STUN server that implements this specification. It relays data between a TURN client and its peer(s).
Peer::: A host with which the TURN client wishes to communicate. The TURN server relays traffic between the TURN client and its peer(s). The peer does not interact with the TURN server using the protocol defined in this document; rather, the peer receives data sent by the TURN server, and the peer sends data towards the TURN server.
Transport Address::: The combination of an IP address and a port.
Host Transport Address::: A transport address on a client or a peer.
Server-Reflexive Transport Address::: A transport address on the "external side" of a NAT. This address is allocated by the NAT to correspond to a specific host transport address.
Relayed Transport Address::: A transport address on the TURN server that is used for relaying packets between the client and a peer. A peer sends to this address on the TURN server, and the packet is then relayed to the client.
TURN Server Transport Address::: A transport address on the TURN server that is used for sending TURN messages to the server. This is the transport address that the client uses to communicate with the server.
Peer Transport Address::: The transport address of the peer as seen by the server. When the peer is behind a NAT, this is the peer's server-reflexive transport address.
Allocation::: The relayed transport address granted to a client through an Allocate request, along with related state, such as permissions and expiration timers.
5-tuple::: The combination (client IP address and port, server IP address and port, and transport protocol (currently one of UDP, TCP, DTLS/UDP, or TLS/TCP)) used to communicate between the client and the server. The 5-tuple uniquely identifies this communication stream. The 5-tuple also uniquely identifies the Allocation on the server.
Transport Protocol::: The protocol above IP that carries TURN Requests, Responses, and Indications as well as providing identifiable flows using a 5-tuple. In this specification, UDP and TCP are defined as transport protocols; this document also describes the use of UDP and TCP in combination with a security layer using DTLS and TLS, respectively.
Channel::: A channel number and associated peer transport address. Once a channel number is bound to a peer's transport address, the client and server can use the more bandwidth-efficient ChannelData message to exchange data.
Permission::: The IP address and transport protocol (but not the port) of a peer that is permitted to send traffic to the TURN server and have that traffic relayed to the TURN client. The TURN server will only forward traffic to its client from peers that match an existing permission.
Realm::: A string used to describe the server or a context within the server. The realm tells the client which username and password combination to use to authenticate requests.
Nonce::: A string chosen at random by the server and included in the server response. To prevent replay attacks, the server should change the nonce regularly.
(D)TLS::: This term is used for statements that apply to both Transport Layer Security <<RFC8446,format=default>> and Datagram Transport Layer Security <<RFC6347,format=default>>.

[[sec-overview]]
[numbered=true,removeInRFC=false,toc=include]
== Overview of Operation

This section gives an overview of the operation of TURN. It is non-normative.

In a typical configuration, a TURN client is connected to a private network <<RFC1918,format=default>> and, through one or more NATs, to the public Internet. On the public Internet is a TURN server. Elsewhere in the Internet are one or more peers with which the TURN client wishes to communicate. These peers may or may not be behind one or more NATs. The client uses the server as a relay to send packets to these peers and to receive packets from these peers.

[[fig-turn-model]]
[suppress-title=false,align=left,alt=]
[align=left,alt=,]
....
                                    Peer A
                                    Server-Reflexive    +---------+
                                    Transport Address   |         |
                                    192.0.2.150:32102   |         |
                                        |              /|         |
                      TURN              |            / ^|  Peer A |
   Client's           Server            |           /  ||         |
   Host Transport     Transport         |         //   ||         |
   Address            Address           |       //     |+---------+
198.51.100.2:49721  192.0.2.15:3478     |+-+  //     Peer A
           |            |               ||N| /       Host Transport
           |   +-+      |               ||A|/        Address
           |   | |      |               v|T|     203.0.113.2:49582
           |   | |      |               /+-+       
+---------+|   | |      |+---------+   /              +---------+
|         ||   |N|      ||         | //               |         |
| TURN    |v   | |      v| TURN    |/                 |         |
| Client  |----|A|-------| Server  |------------------|  Peer B |
|         |    | |^      |         |^                ^|         |
|         |    |T||      |         ||                ||         |
+---------+    | ||      +---------+|                |+---------+
               | ||                 |                |
               | ||                 |                |
               +-+|                 |                |
                  |                 |                |
                  |                 |                |
         Client's                   |             Peer B
         Server-Reflexive     Relayed             Transport
         Transport Address    Transport Address   Address
         192.0.2.1:7000       192.0.2.15:50000    192.0.2.210:49191
....

<<fig-turn-model,format=default>> shows a typical deployment. In this figure, the TURN client and the TURN server are separated by a NAT, with the client on the private side and the server on the public side of the NAT. This NAT is assumed to be a "bad" NAT; for example, it might have a mapping property of "address-and-port-dependent mapping" (see <<RFC4787,format=default>>).

The client talks to the server from a (IP address, port) combination called the client's "host transport address". (The combination of an IP address and port is called a "transport address".)

The client sends TURN messages from its host transport address to a transport address on the TURN server that is known as the "TURN server transport address". The client learns the TURN server transport address through some unspecified means (e.g., configuration), and this address is typically used by many clients simultaneously.

Since the client is behind a NAT, the server sees packets from the client as coming from a transport address on the NAT itself. This address is known as the client's "server-reflexive transport address"; packets sent by the server to the client's server-reflexive transport address will be forwarded by the NAT to the client's host transport address.

The client uses TURN commands to create and manipulate an ALLOCATION on the server. An allocation is a data structure on the server. This data structure contains, amongst other things, the relayed transport address for the allocation. The relayed transport address is the transport address on the server that peers can use to have the server relay data to the client. An allocation is uniquely identified by its relayed transport address.

Once an allocation is created, the client can send application data to the server along with an indication of to which peer the data is to be sent, and the server will relay this data to the intended peer. The client sends the application data to the server inside a TURN message; at the server, the data is extracted from the TURN message and sent to the peer in a UDP datagram. In the reverse direction, a peer can send application data in a UDP datagram to the relayed transport address for the allocation; the server will then encapsulate this data inside a TURN message and send it to the client along with an indication of which peer sent the data. Since the TURN message always contains an indication of which peer the client is communicating with, the client can use a single allocation to communicate with multiple peers.

When the peer is behind a NAT, the client must identify the peer using its server-reflexive transport address rather than its host transport address. For example, to send application data to Peer A in the example above, the client must specify 192.0.2.150:32102 (Peer A's server-reflexive transport address) rather than 203.0.113.2:49582 (Peer A's host transport address).

Each allocation on the server belongs to a single client and has either one or two relayed transport addresses that are used only by that allocation. Thus, when a packet arrives at a relayed transport address on the server, the server knows for which client the data is intended.

The client may have multiple allocations on a server at the same time.

[[sec-transports]]
[numbered=true,removeInRFC=false,toc=include]
=== Transports

TURN, as defined in this specification, always uses UDP between the server and the peer. However, this specification allows the use of any one of UDP, TCP, Transport Layer Security (TLS) over TCP, or Datagram Transport Layer Security (DTLS) over UDP to carry the TURN messages between the client and the server.

[align=center]
|===
h|TURN client to TURN server | TURN server to peer
|:--: | :--:

|UDP | UDP
|TCP | UDP
|TLS-over-TCP | UDP
|DTLS-over-UDP | UDP
|===

If TCP or TLS-over-TCP is used between the client and the server, then the server will convert between these transports and UDP transport when relaying data to/from the peer.

Since this version of TURN only supports UDP between the server and the peer, it is expected that most clients will prefer to use UDP between the client and the server as well. That being the case, some readers may wonder: Why also support TCP and TLS-over-TCP?

TURN supports TCP transport between the client and the server because some firewalls are configured to block UDP entirely. These firewalls block UDP but not TCP, in part because TCP has properties that make the intention of the nodes being protected by the firewall more obvious to the firewall. For example, TCP has a three-way handshake that makes it clearer that the protected node really wishes to have that particular connection established, while for UDP, the best the firewall can do is guess which flows are desired by using filtering rules. Also, TCP has explicit connection teardown; while for UDP, the firewall has to use timers to guess when the flow is finished.

TURN supports TLS-over-TCP transport and DTLS-over-UDP transport between the client and the server because (D)TLS provides additional security properties not provided by TURN's default digest authentication, properties that some clients may wish to take advantage of. In particular, (D)TLS provides a way for the client to ascertain that it is talking to the correct server and provides for confidentiality of TURN control messages. If (D)TLS transport is used between the TURN client and the TURN server, refer to <<RFC8489,format=default>> for more information about cipher suites, server certificate validation, and authentication of TURN servers. The guidance given in <<RFC7525,format=default>>[bcp14]#MUST# be followed to avoid attacks on (D)TLS. TURN does not require (D)TLS because the overhead of using (D)TLS is higher than that of digest authentication; for example, using (D)TLS likely means that most application data will be doubly encrypted (once by (D)TLS and once to ensure it is still encrypted in the UDP datagram).

There is an extension to TURN for TCP transport between the server and the peers <<RFC6062,format=default>>. For this reason, allocations that use UDP between the server and the peers are known as "UDP allocations", while allocations that use TCP between the server and the peers are known as "TCP allocations". This specification describes only UDP allocations.

In some applications for TURN, the client may send and receive packets other than TURN packets on the host transport address it uses to communicate with the server. This can happen, for example, when using TURN with ICE. In these cases, the client can distinguish TURN packets from other packets by examining the source address of the arriving packet; those arriving from the TURN server will be TURN packets. The algorithm of demultiplexing packets received from multiple protocols on the host transport address is discussed in <<RFC7983,format=default>>.

[numbered=true,removeInRFC=false,toc=include]
=== Allocations

To create an allocation on the server, the client uses an Allocate transaction. The client sends an Allocate request to the server, and the server replies with an Allocate success response containing the allocated relayed transport address. The client can include attributes in the Allocate request that describe the type of allocation it desires (e.g., the lifetime of the allocation). Since relaying data has security implications, the server requires that the client authenticate itself, typically using STUN's long-term credential mechanism or the STUN Extension for Third-Party Authorization <<RFC7635,format=default>>, to show that it is authorized to use the server.

Once a relayed transport address is allocated, a client must keep the allocation alive. To do this, the client periodically sends a Refresh request to the server. TURN deliberately uses a different method (Refresh rather than Allocate) for refreshes to ensure that the client is informed if the allocation vanishes for some reason.

The frequency of the Refresh transaction is determined by the lifetime of the allocation. The default lifetime of an allocation is 10 minutes; this value was chosen to be long enough so that refreshing is not typically a burden on the client while expiring allocations where the client has unexpectedly quit in a timely manner. However, the client can request a longer lifetime in the Allocate request and may modify its request in a Refresh request, and the server always indicates the actual lifetime in the response. The client must issue a new Refresh transaction within "lifetime" seconds of the previous Allocate or Refresh transaction. Once a client no longer wishes to use an allocation, it should delete the allocation using a Refresh request with a requested lifetime of zero.

Both the server and client keep track of a value known as the "5-tuple". At the client, the 5-tuple consists of the client's host transport address, the server transport address, and the transport protocol used by the client to communicate with the server. At the server, the 5-tuple value is the same except that the client's host transport address is replaced by the client's server-reflexive address since that is the client's address as seen by the server.

Both the client and the server remember the 5-tuple used in the Allocate request. Subsequent messages between the client and the server use the same 5-tuple. In this way, the client and server know which allocation is being referred to. If the client wishes to allocate a second relayed transport address, it must create a second allocation using a different 5-tuple (e.g., by using a different client host address or port).

NOTE: NOTE: While the terminology used in this document refers to 5-tuples, the TURN server can store whatever identifier it likes that yields identical results. Specifically, an implementation may use a file descriptor in place of a 5-tuple to represent a TCP connection.
[[fig-allocate]]
[suppress-title=false,align=left,alt=]
[align=left,alt=,]
....
TURN                                 TURN          Peer         Peer
client                               server         A            B
  |-- Allocate request --------------->|            |            |
  |   (invalid or missing credentials) |            |            |     
  |                                    |            |            |
  |<--------------- Allocate failure --|            |            |
  |              (401 Unauthenticated) |            |            |
  |                                    |            |            |
  |-- Allocate request --------------->|            |            |
  |               (valid credentials)  |            |            |
  |                                    |            |            |
  |<---------- Allocate success resp --|            |            |
  |            (192.0.2.15:50000)      |            |            |
  //                                   //           //           //
  |                                    |            |            |
  |-- Refresh request ---------------->|            |            |
  |                                    |            |            |
  |<----------- Refresh success resp --|            |            |
  |                                    |            |            |
....

In <<fig-allocate,format=default>>, the client sends an Allocate request to the server with invalid or missing credentials. Since the server requires that all requests be authenticated using STUN's long-term credential mechanism, the server rejects the request with a 401 (Unauthorized) error code. The client then tries again, this time including credentials. This time, the server accepts the Allocate request and returns an Allocate success response containing (amongst other things) the relayed transport address assigned to the allocation. Sometime later, the client decides to refresh the allocation; thus, it sends a Refresh request to the server. The refresh is accepted and the server replies with a Refresh success response.

[[sec-permission-overview]]
[numbered=true,removeInRFC=false,toc=include]
=== Permissions

To ease concerns amongst enterprise IT administrators that TURN could be used to bypass corporate firewall security, TURN includes the notion of permissions. TURN permissions mimic the address-restricted filtering mechanism of NATs that comply with <<RFC4787,format=default>>.

An allocation can have zero or more permissions. Each permission consists of an IP address and a lifetime. When the server receives a UDP datagram on the allocation's relayed transport address, it first checks the list of permissions. If the source IP address of the datagram matches a permission, the application data is relayed to the client; otherwise, the UDP datagram is silently discarded.

A permission expires after 5 minutes if it is not refreshed, and there is no way to explicitly delete a permission. This behavior was selected to match the behavior of a NAT that complies with <<RFC4787,format=default>>.

The client can install or refresh a permission using either a CreatePermission request or a ChannelBind request. Using the CreatePermission request, multiple permissions can be installed or refreshed with a single request; this is important for applications that use ICE. For security reasons, permissions can only be installed or refreshed by transactions that can be authenticated; thus, Send indications and ChannelData messages (which are used to send data to peers) do not install or refresh any permissions.

Note that permissions are within the context of an allocation, so adding or expiring a permission in one allocation does not affect other allocations.

[numbered=true,removeInRFC=false,toc=include]
=== Send Mechanism

There are two mechanisms for the client and peers to exchange application data using the TURN server. The first mechanism uses the Send and Data methods, the second mechanism uses channels. Common to both mechanisms is the ability of the client to communicate with multiple peers using a single allocated relayed transport address; thus, both mechanisms include a means for the client to indicate to the server which peer should receive the data and for the server to indicate to the client which peer sent the data.

The Send mechanism uses Send and Data indications. Send indications are used to send application data from the client to the server, while Data indications are used to send application data from the server to the client.

When using the Send mechanism, the client sends a Send indication to the TURN server containing (a) an XOR-PEER-ADDRESS attribute specifying the (server-reflexive) transport address of the peer and (b) a DATA attribute holding the application data. When the TURN server receives the Send indication, it extracts the application data from the DATA attribute and sends it in a UDP datagram to the peer, using the allocated relay address as the source address. Note that there is no need to specify the relayed transport address since it is implied by the 5-tuple used for the Send indication.

In the reverse direction, UDP datagrams arriving at the relayed transport address on the TURN server are converted into Data indications and sent to the client, with the server-reflexive transport address of the peer included in an XOR-PEER-ADDRESS attribute and the data itself in a DATA attribute. Since the relayed transport address uniquely identified the allocation, the server knows which client should receive the data.

Some ICMP (Internet Control Message Protocol) packets arriving at the relayed transport address on the TURN server may be converted into Data indications and sent to the client, with the transport address of the peer included in an XOR-PEER-ADDRESS attribute and the ICMP type and code in an ICMP attribute. ICMP attribute forwarding always uses Data indications containing the XOR-PEER-ADDRESS and ICMP attributes, even when using the channel mechanism to forward UDP data.

Send and Data indications cannot be authenticated since the long-term credential mechanism of STUN does not support authenticating indications. This is not as big an issue as it might first appear since the client-to-server leg is only half of the total path to the peer. Applications that want end-to-end security should encrypt the data sent between the client and a peer.

Because Send indications are not authenticated, it is possible for an attacker to send bogus Send indications to the server, which will then relay these to a peer. To partly mitigate this attack, TURN requires that the client install a permission towards a peer before sending data to it using a Send indication. The technique to fully mitigate the attack is discussed in <<fate-data,format=default>>.

[[fig-send-data]]
[suppress-title=false,align=left,alt=]
[align=left,alt=,]
....
TURN                                TURN           Peer          Peer
client                              server          A             B
  |                                   |             |             |
  |-- CreatePermission req (Peer A) ->|             |             |
  |<- CreatePermission success resp --|             |             |
  |                                   |             |             |
  |--- Send ind (Peer A)------------->|             |             |
  |                                   |=== data ===>|             |
  |                                   |             |             |
  |                                   |<== data ====|             |
  |<------------- Data ind (Peer A) --|             |             |
  |                                   |             |             |
  |                                   |             |             |
  |--- Send ind (Peer B)------------->|             |             |
  |                                   | dropped     |             |
  |                                   |             |             |
  |                                   |<== data ==================|
  |                           dropped |             |             |
  |                                   |             |             |
....

In <<fig-send-data,format=default>>, the client has already created an allocation and now wishes to send data to its peers. The client first creates a permission by sending the server a CreatePermission request specifying Peer A's (server-reflexive) IP address in the XOR-PEER-ADDRESS attribute; if this was not done, the server would not relay data between the client and the server. The client then sends data to Peer A using a Send indication; at the server, the application data is extracted and forwarded in a UDP datagram to Peer A, using the relayed transport address as the source transport address. When a UDP datagram from Peer A is received at the relayed transport address, the contents are placed into a Data indication and forwarded to the client. Later, the client attempts to exchange data with Peer B; however, no permission has been installed for Peer B, so the Send indication from the client and the UDP datagram from the peer are both dropped by the server.

[numbered=true,removeInRFC=false,toc=include]
=== Channels

For some applications (e.g., Voice over IP (VoIP)), the 36 bytes of overhead that a Send indication or Data indication adds to the application data can substantially increase the bandwidth required between the client and the server. To remedy this, TURN offers a second way for the client and server to associate data with a specific peer.

This second way uses an alternate packet format known as the "ChannelData message". The ChannelData message does not use the STUN header used by other TURN messages, but instead has a 4-byte header that includes a number known as a "channel number". Each channel number in use is bound to a specific peer; thus, it serves as a shorthand for the peer's host transport address.

To bind a channel to a peer, the client sends a ChannelBind request to the server and includes an unbound channel number and the transport address of the peer. Once the channel is bound, the client can use a ChannelData message to send the server data destined for the peer. Similarly, the server can relay data from that peer towards the client using a ChannelData message.

Channel bindings last for 10 minutes unless refreshed; this lifetime was chosen to be longer than the permission lifetime. Channel bindings are refreshed by sending another ChannelBind request rebinding the channel to the peer. Like permissions (but unlike allocations), there is no way to explicitly delete a channel binding; the client must simply wait for it to time out.

[[fig-channels]]
[suppress-title=false,align=left,alt=]
[align=left,alt=,]
....
TURN                                TURN           Peer          Peer
client                              server          A             B
  |                                   |             |             |
  |-- ChannelBind req --------------->|             |             |
  | (Peer A to 0x4001)                |             |             |
  |                                   |             |             |
  |<---------- ChannelBind succ resp -|             |             |
  |                                   |             |             |
  |-- (0x4001) data ----------------->|             |             |
  |                                   |=== data ===>|             |
  |                                   |             |             |
  |                                   |<== data ====|             |
  |<------------------ (0x4001) data -|             |             |
  |                                   |             |             |
  |--- Send ind (Peer A)------------->|             |             |
  |                                   |=== data ===>|             |
  |                                   |             |             |
  |                                   |<== data ====|             |
  |<------------------ (0x4001) data -|             |             |
  |                                   |             |             |
....

<<fig-channels,format=default>> shows the channel mechanism in use. The client has already created an allocation and now wishes to bind a channel to Peer A. To do this, the client sends a ChannelBind request to the server, specifying the transport address of Peer A and a channel number (0x4001). After that, the client can send application data encapsulated inside ChannelData messages to Peer A: this is shown as "(0x4001) data" where 0x4001 is the channel number. When the ChannelData message arrives at the server, the server transfers the data to a UDP datagram and sends it to Peer A (which is the peer bound to channel number 0x4001).

In the reverse direction, when Peer A sends a UDP datagram to the relayed transport address, this UDP datagram arrives at the server on the relayed transport address assigned to the allocation. Since the UDP datagram was received from Peer A, which has a channel number assigned to it, the server encapsulates the data into a ChannelData message when sending the data to the client.

Once a channel has been bound, the client is free to intermix ChannelData messages and Send indications. In the figure, the client later decides to use a Send indication rather than a ChannelData message to send additional data to Peer A. The client might decide to do this, for example, so it can use the DONT-FRAGMENT attribute (see the next section). However, once a channel is bound, the server will always use a ChannelData message, as shown in the call flow.

Note that ChannelData messages can only be used for peers to which the client has bound a channel. In the example above, Peer A has been bound to a channel, but Peer B has not, so application data to and from Peer B would use the Send mechanism.

[[unpriv]]
[numbered=true,removeInRFC=false,toc=include]
=== Unprivileged TURN Servers

This version of TURN is designed so that the server can be implemented as an application that runs in user space under commonly available operating systems without requiring special privileges. This design decision was made to make it easy to deploy a TURN server: for example, to allow a TURN server to be integrated into a peer-to-peer application so that one peer can offer NAT traversal services to another peer and to use (D)TLS to secure the TURN connection.

This design decision has the following implications for data relayed by a TURN server:

[nobullet=false,spacing=normal]
* The value of the Diffserv field may not be preserved across the server;
* The Time to Live (TTL) field may be reset, rather than decremented, across the server;
* The Explicit Congestion Notification (ECN) field may be reset by the server;
* There is no end-to-end fragmentation since the packet is reassembled at the server.

Future work may specify alternate TURN semantics that address these limitations.

[numbered=true,removeInRFC=false,toc=include]
=== Avoiding IP Fragmentation

For reasons described in <<FRAG-HARMFUL,format=default>>, applications, especially those sending large volumes of data, should avoid having their packets fragmented. <<I-D.ietf-intarea-frag-fragile,format=default: FRAG-FRAGILE>> discusses issues associated with IP fragmentation and proposes alternatives to IP fragmentation. Applications using TCP can, more or less, ignore this issue because fragmentation avoidance is now a standard part of TCP, but applications using UDP (and, thus, any application using this version of TURN) need to avoid IP fragmentation by sending sufficiently small messages or by using UDP fragmentation <<I-D.ietf-tsvwg-udp-options,format=default: UDP-OPT>>. Note that the UDP fragmentation option needs to be supported by both endpoints, and at the time of writing of this document, UDP fragmentation support is under discussion and is not deployed.

The application running on the client and the peer can take one of two approaches to avoid IP fragmentation until UDP fragmentation support is available. The first uses messages that are limited to a predetermined fixed maximum, and the second relies on network feedback to adapt that maximum.

The first approach is to avoid sending large amounts of application data in the TURN messages/UDP datagrams exchanged between the client and the peer. This is the approach taken by most VoIP applications. In this approach, the application [bcp14]#MUST# assume a Path MTU (PMTU) of 1280 bytes because IPv6 requires that every link in the Internet has an MTU of 1280 octets or greater as specified in <<RFC8200,format=default>>. If IPv4 support on legacy or otherwise unusual networks is a consideration, the application [bcp14]#MAY# assume an effective MTU of 576 bytes for IPv4 datagrams, as every IPv4 host must be capable of receiving a packet with a length equal to 576 bytes as discussed in <<RFC0791,format=default>> and <<RFC1122,format=default>>.

The exact amount of application data that can be included while avoiding fragmentation depends on the details of the TURN session between the client and the server: whether UDP, TCP, or (D)TLS transport is used; whether ChannelData messages or Send/Data indications are used; and whether any additional attributes (such as the DONT-FRAGMENT attribute) are included. Another factor, which is hard to determine, is whether the MTU is reduced somewhere along the path for other reasons, such as the use of IP-in-IP tunneling.

As a guideline, sending a maximum of 500 bytes of application data in a single TURN message (by the client on the client-to-server leg) or a UDP datagram (by the peer on the peer-to-server leg) will generally avoid IP fragmentation. To further reduce the chance of fragmentation, it is recommended that the client use ChannelData messages when transferring significant volumes of data since the overhead of the ChannelData message is less than Send and Data indications.

The second approach the client and peer can take to avoid fragmentation is to use a path MTU discovery algorithm to determine the maximum amount of application data that can be sent without fragmentation. The classic path MTU discovery algorithm defined in <<RFC1191,format=default>> may not be able to discover the MTU of the transmission path between the client and the peer since:

[nobullet=false,spacing=normal]
* A probe packet with a Don't Fragment (DF) bit in the IPv4 header set to test a path for a larger MTU can be dropped by routers, or
* ICMP error messages can be dropped by middleboxes.

As a result, the client and server need to use a path MTU discovery algorithm that does not require ICMP messages. The Packetized Path MTU Discovery algorithm defined in <<RFC4821,format=default>> is one such algorithm, and a set of algorithms is defined in <<I-D.ietf-tsvwg-datagram-plpmtud,format=default: MTU-DATAGRAM>>.

<<I-D.ietf-tram-stun-pmtud,format=default: MTU-STUN>> is an implementation of <<RFC4821,format=default>> that uses STUN to discover the path MTU; so it might be a suitable approach to be used in conjunction with a TURN server that supports the DONT-FRAGMENT attribute. When the client includes the DONT-FRAGMENT attribute in a Send indication, this tells the server to set the DF bit in the resulting UDP datagram that it sends to the peer. Since some servers may be unable to set the DF bit, the client should also include this attribute in the Allocate request; any server that does not support the DONT-FRAGMENT attribute will indicate this by rejecting the Allocate request. If the TURN server carrying out packet translation from IPv4-to-IPv6 is unable to access the state of the Don't Fragment (DF) bit in the IPv4 header, it [bcp14]#MUST# reject the Allocate request with the DONT-FRAGMENT attribute.

[numbered=true,removeInRFC=false,toc=include]
=== RTP Support

One of the envisioned uses of TURN is as a relay for clients and peers wishing to exchange real-time data (e.g., voice or video) using RTP. To facilitate the use of TURN for this purpose, TURN includes some special support for older versions of RTP.

Old versions of RTP <<RFC3550,format=default>> required that the RTP stream be on an even port number and the associated RTP Control Protocol (RTCP) stream, if present, be on the next highest port. To allow clients to work with peers that still require this, TURN allows the client to request that the server allocate a relayed transport address with an even port number and optionally request the server reserve the next-highest port number for a subsequent allocation.

[numbered=true,removeInRFC=false,toc=include]
=== Happy Eyeballs for TURN

If an IPv4 path to reach a TURN server is found, but the TURN server's IPv6 path is not working, a dual-stack TURN client can experience a significant connection delay compared to an IPv4-only TURN client. To overcome these connection setup problems, the TURN client needs to query both A and AAAA records for the TURN server specified using a domain name and try connecting to the TURN server using both IPv6 and IPv4 addresses in a fashion similar to the Happy Eyeballs mechanism defined in <<RFC8305,format=default>>. The TURN client performs the following steps based on the transport protocol being used to connect to the TURN server.

[nobullet=false,spacing=normal]
* For TCP or TLS-over-TCP, the results of the Happy Eyeballs procedure<<RFC8305,format=default>>are used by the TURN client for sending its TURN messages to the server.
* For clear text UDP, send TURN Allocate requests to both IP address families as discussed in<<RFC8305,format=default>>without authentication information. If the TURN server requires authentication, it will send back a 401 unauthenticated response; the TURN client will use the first UDP connection on which a 401 error response is received. If a 401 error response is received from both IP address families, then the TURN client can silently abandon the UDP connection on the IP address family with lower precedence. If the TURN server does not require authentication (as described in<<RFC8155,format=default>>), it is possible for both Allocate requests to succeed. In this case, the TURN client sends a Refresh with a LIFETIME value of zero on the allocation using the IP address family with lower precedence to delete the allocation.
* For DTLS over UDP, initiate a DTLS handshake to both IP address families as discussed in<<RFC8305,format=default>>, and use the first DTLS session that is established. If the DTLS session is established on both IP address families, then the client sends a DTLS close_notify alert to terminate the DTLS session using the IP address family with lower precedence. If the TURN over DTLS server has been configured to require a cookie exchange (<<RFC6347,format=default>>) and a HelloVerifyRequest is received from the TURN servers on both IP address families, then the client can silently abandon the connection on the IP address family with lower precedence.

[numbered=true,removeInRFC=false,toc=include]
== Discovery of TURN Server

Methods of TURN server discovery, including using anycast, are described in <<RFC8155,format=default>>. If a host with multiple interfaces discovers a TURN server in each interface, the mechanism described in <<RFC7982,format=default>> can be used by the TURN client to influence the TURN server selection. The syntax of the "turn" and "turns" URIs are defined in <<RFC7065,format=default>>. DTLS as a transport protocol for TURN is defined in <<RFC7350,format=default>>.

[numbered=true,removeInRFC=false,toc=include]
=== TURN URI Scheme Semantics

The "turn" and "turns" URI schemes are used to designate a TURN server (also known as a "relay") on Internet hosts accessible using the TURN protocol. The TURN protocol supports sending messages over UDP, TCP, TLS-over-TCP, or DTLS-over-UDP. The "turns" URI scheme [bcp14]#MUST# be used when TURN is run over TLS-over-TCP or in DTLS-over-UDP, and the "turn" scheme [bcp14]#MUST# be used otherwise. The required <host> part of the "turn" URI denotes the TURN server host. The <port> part, if present, denotes the port on which the TURN server is awaiting connection requests. If it is absent, the default port is 3478 for both UDP and TCP. The default port for TURN over TLS and TURN over DTLS is 5349.

[[sec-general-behavior]]
[numbered=true,removeInRFC=false,toc=include]
== General Behavior

This section contains general TURN processing rules that apply to all TURN messages.

TURN is an extension to STUN. All TURN messages, with the exception of the ChannelData message, are STUN-formatted messages. All the base processing rules described in <<RFC8489,format=default>> apply to STUN-formatted messages. This means that all the message-forming and message-processing descriptions in this document are implicitly prefixed with the rules of <<RFC8489,format=default>>.

<<RFC8489,format=default>> specifies an authentication mechanism called the "long-term credential mechanism". TURN servers and clients [bcp14]#MUST# implement this mechanism, and the authentication options are discussed in <<sec-rcv-allocate,format=default>>.

Note that the long-term credential mechanism applies only to requests and cannot be used to authenticate indications; thus, indications in TURN are never authenticated. If the server requires requests to be authenticated, then the server's administrator [bcp14]#MUST# choose a realm value that will uniquely identify the username and password combination that the client must use, even if the client uses multiple servers under different administrations. The server's administrator [bcp14]#MAY# choose to allocate a unique username to each client, or it [bcp14]#MAY# choose to allocate the same username to more than one client (for example, to all clients from the same department or company). For each Allocate request, the server [bcp14]#SHOULD# generate a new random nonce when the allocation is first attempted following the randomness recommendations in <<RFC4086,format=default>> and [bcp14]#SHOULD# expire the nonce at least once every hour during the lifetime of the allocation. The server uses the mechanism described in <<RFC8489,format=default>> to indicate that it supports <<RFC8489,format=default>>.

All requests after the initial Allocate must use the same username as that used to create the allocation to prevent attackers from hijacking the client's allocation.

Specifically, if:

[nobullet=false,spacing=normal]
* the server requires the use of the long-term credential mechanism, and;
* a non-Allocate request passes authentication under this mechanism, and;
* the 5-tuple identifies an existing allocation, but;
* the request does not use the same username as used to create the allocation,

then the request [bcp14]#MUST# be rejected with a 441 (Wrong Credentials) error.

When a TURN message arrives at the server from the client, the server uses the 5-tuple in the message to identify the associated allocation. For all TURN messages (including ChannelData) EXCEPT an Allocate request, if the 5-tuple does not identify an existing allocation, then the message [bcp14]#MUST# either be rejected with a 437 Allocation Mismatch error (if it is a request) or be silently ignored (if it is an indication or a ChannelData message). A client receiving a 437 error response to a request other than Allocate [bcp14]#MUST# assume the allocation no longer exists.

<<RFC8489,format=default>> defines a number of attributes, including the SOFTWARE and FINGERPRINT attributes. The client [bcp14]#SHOULD# include the SOFTWARE attribute in all Allocate and Refresh requests and [bcp14]#MAY# include it in any other requests or indications. The server [bcp14]#SHOULD# include the SOFTWARE attribute in all Allocate and Refresh responses (either success or failure) and [bcp14]#MAY# include it in other responses or indications. The client and the server [bcp14]#MAY# include the FINGERPRINT attribute in any STUN-formatted messages defined in this document.

TURN does not use the backwards-compatibility mechanism described in <<RFC8489,format=default>>.

TURN, as defined in this specification, supports both IPv4 and IPv6. IPv6 support in TURN includes IPv4-to-IPv6, IPv6-to-IPv6, and IPv6-to-IPv4 relaying. When only a single address type is desired, the REQUESTED-ADDRESS-FAMILY attribute is used to explicitly request the address type the TURN server will allocate (e.g., an IPv4-only node may request the TURN server to allocate an IPv6 address). If both IPv4 and IPv6 are desired, the single ADDITIONAL-ADDRESS-FAMILY attribute indicates a request to the server to allocate one IPv4 and one IPv6 relay address in a single Allocate request. This saves local ports on the client and reduces the number of messages sent between the client and the TURN server.

By default, TURN runs on the same ports as STUN: 3478 for TURN over UDP and TCP, and 5349 for TURN over (D)TLS. However, TURN has its own set of Service Record (SRV) names: "turn" for UDP and TCP, and "turns" for (D)TLS. Either the DNS resolution procedures or the ALTERNATE-SERVER procedures, both described in <<sec-create-allocation,format=default>>, can be used to run TURN on a different port.

To ensure interoperability, a TURN server [bcp14]#MUST# support the use of UDP transport between the client and the server, and it [bcp14]#SHOULD# support the use of TCP, TLS-over-TCP, and DTLS-over-UDP transports.

When UDP or DTLS-over-UDP transport is used between the client and the server, the client will retransmit a request if it does not receive a response within a certain timeout period. Because of this, the server may receive two (or more) requests with the same 5-tuple and same transaction id. STUN requires that the server recognize this case and treat the request as idempotent (see <<RFC8489,format=default>>). Some implementations may choose to meet this requirement by remembering all received requests and the corresponding responses for 40 seconds (<<RFC8489,format=default>>). Other implementations may choose to reprocess the request and arrange that such reprocessing returns essentially the same response. To aid implementors who choose the latter approach (the so-called "stateless stack approach"), this specification includes some implementation notes on how this might be done. Implementations are free to choose either approach or some other approach that gives the same results.

To mitigate either intentional or unintentional denial-of-service attacks against the server by clients with valid usernames and passwords, it is [bcp14]#RECOMMENDED# that the server impose limits on both the number of allocations active at one time for a given username and on the amount of bandwidth those allocations can use. The server should reject new allocations that would exceed the limit on the allowed number of allocations active at one time with a 486 (Allocation Quota Exceeded) (see <<sec-rcv-allocate,format=default>>), and since UDP does not include a congestion control mechanism, it should discard application data traffic that exceeds the bandwidth quota.

[[sec-allocations]]
[numbered=true,removeInRFC=false,toc=include]
== Allocations

All TURN operations revolve around allocations, and all TURN messages are associated with either a single or dual allocation. An allocation conceptually consists of the following state data:

[nobullet=false,spacing=normal]
* the relayed transport address or addresses;
* the 5-tuple: (client's IP address, client's port, server IP address, server port, and transport protocol);
* the authentication information;
* the time-to-expiry for each relayed transport address;
* a list of permissions for each relayed transport address;
* a list of channel-to-peer bindings for each relayed transport address.

The relayed transport address is the transport address allocated by the server for communicating with peers, while the 5-tuple describes the communication path between the client and the server. On the client, the 5-tuple uses the client's host transport address; on the server, the 5-tuple uses the client's server-reflexive transport address. The relayed transport address [bcp14]#MUST# be unique across all allocations so it can be used to uniquely identify the allocation, and an allocation in this context can be either a single or dual allocation.

The authentication information (e.g., username, password, realm, and nonce) is used to both verify subsequent requests and to compute the message integrity of responses. The username, realm, and nonce values are initially those used in the authenticated Allocate request that creates the allocation, though the server can change the nonce value during the lifetime of the allocation using a 438 (Stale Nonce) reply. For security reasons, the server [bcp14]#MUST NOT# store the password explicitly and [bcp14]#MUST# store the key value, which is a cryptographic hash over the username, realm, and password (see <<RFC8489,format=default>>).

Note that if the response contains a PASSWORD-ALGORITHMS attribute and this attribute contains both MD5 and SHA-256 algorithms, and the client also supports both the algorithms, the request [bcp14]#MUST# contain a PASSWORD-ALGORITHM attribute with the SHA-256 algorithm.

The time-to-expiry is the time in seconds left until the allocation expires. Each Allocate or Refresh transaction sets this timer, which then ticks down towards zero. By default, each Allocate or Refresh transaction resets this timer to the default lifetime value of 600 seconds (10 minutes), but the client can request a different value in the Allocate and Refresh request. Allocations can only be refreshed using the Refresh request; sending data to a peer does not refresh an allocation. When an allocation expires, the state data associated with the allocation can be freed.

The list of permissions is described in <<sec-permissions,format=default>> and the list of channels is described in <<sec-channels,format=default>>.

[[sec-create-allocation]]
[numbered=true,removeInRFC=false,toc=include]
== Creating an Allocation

An allocation on the server is created using an Allocate transaction.

[[sec-send-allocate]]
[numbered=true,removeInRFC=false,toc=include]
=== Sending an Allocate Request

The client forms an Allocate request as follows.

The client first picks a host transport address. It is [bcp14]#RECOMMENDED# that the client pick a currently unused transport address, typically by allowing the underlying OS to pick a currently unused port.

The client then picks a transport protocol that the client supports to use between the client and the server based on the transport protocols supported by the server. Since this specification only allows UDP between the server and the peers, it is [bcp14]#RECOMMENDED# that the client pick UDP unless it has a reason to use a different transport. One reason to pick a different transport would be that the client believes, either through configuration or discovery or by experiment, that it is unable to contact any TURN server using UDP. See <<sec-transports,format=default>> for more discussion.

The client also picks a server transport address, which [bcp14]#SHOULD# be done as follows. The client uses one or more procedures described in <<RFC8155,format=default>> to discover a TURN server and uses the TURN server resolution mechanism defined in <<RFC5928,format=default>> and <<RFC7350,format=default>> to get a list of server transport addresses that can be tried to create a TURN allocation.

The client [bcp14]#MUST# include a REQUESTED-TRANSPORT attribute in the request. This attribute specifies the transport protocol between the server and the peers (note that this is \*not* the transport protocol that appears in the 5-tuple). In this specification, the REQUESTED-TRANSPORT type is always UDP. This attribute is included to allow future extensions to specify other protocols.

If the client wishes to obtain a relayed transport address of a specific address type, then it includes a REQUESTED-ADDRESS-FAMILY attribute in the request. This attribute indicates the specific address type the client wishes the TURN server to allocate. Clients [bcp14]#MUST NOT# include more than one REQUESTED-ADDRESS-FAMILY attribute in an Allocate request. Clients [bcp14]#MUST NOT# include a REQUESTED-ADDRESS-FAMILY attribute in an Allocate request that contains a RESERVATION-TOKEN attribute, for the reason that the server uses the previously reserved transport address corresponding to the included token and the client cannot obtain a relayed transport address of a specific address type.

If the client wishes to obtain one IPv6 and one IPv4 relayed transport address, then it includes an ADDITIONAL-ADDRESS-FAMILY attribute in the request. This attribute specifies that the server must allocate both address types. The attribute value in the ADDITIONAL-ADDRESS-FAMILY [bcp14]#MUST# be set to 0x02 (IPv6 address family). Clients [bcp14]#MUST NOT# include REQUESTED-ADDRESS-FAMILY and ADDITIONAL-ADDRESS-FAMILY attributes in the same request. Clients [bcp14]#MUST NOT# include the ADDITIONAL-ADDRESS-FAMILY attribute in an Allocate request that contains a RESERVATION-TOKEN attribute. Clients [bcp14]#MUST NOT# include the ADDITIONAL-ADDRESS-FAMILY attribute in an Allocate request that contains an EVEN-PORT attribute with the R (Reserved) bit set to 1. The reason behind the restriction is that if the EVEN-PORT attribute with the R bit set to 1 is allowed with the ADDITIONAL-ADDRESS-FAMILY attribute, two tokens will have to be returned in the success response and changes will be required to the way the RESERVATION-TOKEN attribute is handled.

If the client wishes the server to initialize the time-to-expiry field of the allocation to some value other than the default lifetime, then it [bcp14]#MAY# include a LIFETIME attribute specifying its desired value. This is just a hint, and the server may elect to use a different value. Note that the server will ignore requests to initialize the field to less than the default value.

If the client wishes to later use the DONT-FRAGMENT attribute in one or more Send indications on this allocation, then the client [bcp14]#SHOULD# include the DONT-FRAGMENT attribute in the Allocate request. This allows the client to test whether this attribute is supported by the server.

If the client requires the port number of the relayed transport address to be even, the client includes the EVEN-PORT attribute. If this attribute is not included, then the port can be even or odd. By setting the R bit in the EVEN-PORT attribute to 1, the client can request that the server reserve the next highest port number (on the same IP address) for a subsequent allocation. If the R bit is 0, no such request is made.

The client [bcp14]#MAY# also include a RESERVATION-TOKEN attribute in the request to ask the server to use a previously reserved port for the allocation. If the RESERVATION-TOKEN attribute is included, then the client [bcp14]#MUST# omit the EVEN-PORT attribute.

Once constructed, the client sends the Allocate request on the 5-tuple.

[[sec-rcv-allocate]]
[numbered=true,removeInRFC=false,toc=include]
=== Receiving an Allocate Request

When the server receives an Allocate request, it performs the following checks:

[spacing=normal,start=1,format=arabic]
. The TURN server provided by the local or access network[bcp14]#MAY#allow an unauthenticated request in order to accept Allocation requests from new and/or guest users in the network who do not necessarily possess long-term credentials for STUN authentication. The security implications of STUN and making STUN authentication optional are discussed in<<RFC8155,format=default>>. Otherwise, the server[bcp14]#MUST#require that the request be authenticated. If the request is authenticated, the authentication[bcp14]#MUST#be done either using the long-term credential mechanism of<<RFC8489,format=default>>or using the STUN Extension for Third-Party Authorization<<RFC7635,format=default>>unless the client and server agree to use another mechanism through some procedure outside the scope of this document.
. The server checks if the 5-tuple is currently in use by an existing allocation. If yes, the server rejects the request with a 437 (Allocation Mismatch) error.
. The server checks if the request contains a REQUESTED-TRANSPORT attribute. If the REQUESTED-TRANSPORT attribute is not included or is malformed, the server rejects the request with a 400 (Bad Request) error. Otherwise, if the attribute is included but specifies a protocol that is not supported by the server, the server rejects the request with a 442 (Unsupported Transport Protocol) error.
. The request may contain a DONT-FRAGMENT attribute. If it does, but the server does not support sending UDP datagrams with the DF bit set to 1 (see Sections<<sec-ip-header-fields,format=counter>>and<<sec-ip-header-fields-tcp-udp,format=counter>>), then the server treats the DONT-FRAGMENT attribute in the Allocate request as an unknown comprehension-required attribute.
. The server checks if the request contains a RESERVATION-TOKEN attribute. If yes, and the request also contains an EVEN-PORT or REQUESTED-ADDRESS-FAMILY or ADDITIONAL-ADDRESS-FAMILY attribute, the server rejects the request with a 400 (Bad Request) error. Otherwise, it checks to see if the token is valid (i.e., the token is in range and has not expired, and the corresponding relayed transport address is still available). If the token is not valid for some reason, the server rejects the request with a 508 (Insufficient Capacity) error.
. The server checks if the request contains both REQUESTED-ADDRESS-FAMILY and ADDITIONAL-ADDRESS-FAMILY attributes. If yes, then the server rejects the request with a 400 (Bad Request) error.
. If the server does not support the address family requested by the client in REQUESTED-ADDRESS-FAMILY, or if the allocation of the requested address family is disabled by local policy, it[bcp14]#MUST#generate an Allocate error response, and it[bcp14]#MUST#include an ERROR-CODE attribute with the 440 (Address Family not Supported) response code. If the REQUESTED-ADDRESS-FAMILY attribute is absent and the server does not support the IPv4 address family, the server[bcp14]#MUST#include an ERROR-CODE attribute with the 440 (Address Family not Supported) response code. If the REQUESTED-ADDRESS-FAMILY attribute is absent and the server supports the IPv4 address family, the server[bcp14]#MUST#allocate an IPv4 relayed transport address for the TURN client.
. The server checks if the request contains an EVEN-PORT attribute with the R bit set to 1. If yes, and the request also contains an ADDITIONAL-ADDRESS-FAMILY attribute, the server rejects the request with a 400 (Bad Request) error. Otherwise, the server checks if it can satisfy the request (i.e., can allocate a relayed transport address as described below). If the server cannot satisfy the request, then the server rejects the request with a 508 (Insufficient Capacity) error.
. The server checks if the request contains an ADDITIONAL-ADDRESS-FAMILY attribute. If yes, and the attribute value is 0x01 (IPv4 address family), then the server rejects the request with a 400 (Bad Request) error. Otherwise, the server checks if it can allocate relayed transport addresses of both address types. If the server cannot satisfy the request, then the server rejects the request with a 508 (Insufficient Capacity) error. If the server can partially meet the request, i.e., if it can only allocate one relayed transport address of a specific address type, then it includes ADDRESS-ERROR-CODE attribute in the success response to inform the client the reason for partial failure of the request. The error code value signaled in the ADDRESS-ERROR-CODE attribute could be 440 (Address Family not Supported) or 508 (Insufficient Capacity). If the server can fully meet the request, then the server allocates one IPv4 and one IPv6 relay address and returns an Allocate success response containing the relayed transport addresses assigned to the dual allocation in two XOR-RELAYED-ADDRESS attributes.
. At any point, the server[bcp14]#MAY#choose to reject the request with a 486 (Allocation Quota Reached) error if it feels the client is trying to exceed some locally defined allocation quota. The server is free to define this allocation quota any way it wishes, but it[bcp14]#SHOULD#define it based on the username used to authenticate the request and not on the client's transport address.
. Also, at any point, the server[bcp14]#MAY#choose to reject the request with a 300 (Try Alternate) error if it wishes to redirect the client to a different server. The use of this error code and attribute follows the specification in<<RFC8489,format=default>>.

If all the checks pass, the server creates the allocation. The 5-tuple is set to the 5-tuple from the Allocate request, while the list of permissions and the list of channels are initially empty.

The server chooses a relayed transport address for the allocation as follows:

[nobullet=false,spacing=normal]
* If the request contains a RESERVATION-TOKEN attribute, the server uses the previously reserved transport address corresponding to the included token (if it is still available). Note that the reservation is a server-wide reservation and is not specific to a particular allocation since the Allocate request containing the RESERVATION-TOKEN uses a different 5-tuple than the Allocate request that made the reservation. The 5-tuple for the Allocate request containing the RESERVATION-TOKEN attribute can be any allowed 5-tuple; it can use a different client IP address and port, a different transport protocol, and even a different server IP address and port (provided, of course, that the server IP address and port are ones on which the server is listening for TURN requests).
* If the request contains an EVEN-PORT attribute with the R bit set to 0, then the server allocates a relayed transport address with an even port number.
* If the request contains an EVEN-PORT attribute with the R bit set to 1, then the server looks for a pair of port numbers N and N+1 on the same IP address, where N is even. Port N is used in the current allocation, while the relayed transport address with port N+1 is assigned a token and reserved for a future allocation. The server[bcp14]#MUST#hold this reservation for at least 30 seconds and[bcp14]#MAY#choose to hold longer (e.g., until the allocation with port N expires). The server then includes the token in a RESERVATION-TOKEN attribute in the success response.
* Otherwise, the server allocates any available relayed transport address.

In all cases, the server [bcp14]#SHOULD# only allocate ports from the range 49152 - 65535 (the Dynamic and/or Private Port range <<PORT-NUMBERS,format=default>>), unless the TURN server application knows, through some means not specified here, that other applications running on the same host as the TURN server application will not be impacted by allocating ports outside this range. This condition can often be satisfied by running the TURN server application on a dedicated machine and/or by arranging that any other applications on the machine allocate ports before the TURN server application starts. In any case, the TURN server [bcp14]#SHOULD NOT# allocate ports in the range 0 - 1023 (the Well-Known Port range) to discourage clients from using TURN to run standard services.

NOTE: NOTE: The use of randomized port assignments to avoid certain types of attacks is described in <<RFC6056,format=default>>. It is [bcp14]#RECOMMENDED# that a TURN server implement a randomized port assignment algorithm from <<RFC6056,format=default>>. This is especially applicable to servers that choose to pre-allocate a number of ports from the underlying OS and then later assign them to allocations; for example, a server may choose this technique to implement the EVEN-PORT attribute.
The server determines the initial value of the time-to-expiry field as follows. If the request contains a LIFETIME attribute, then the server computes the minimum of the client's proposed lifetime and the server's maximum allowed lifetime. If this computed value is greater than the default lifetime, then the server uses the computed lifetime as the initial value of the time-to-expiry field. Otherwise, the server uses the default lifetime. It is [bcp14]#RECOMMENDED# that the server use a maximum allowed lifetime value of no more than 3600 seconds (1 hour). Servers that implement allocation quotas or charge users for allocations in some way may wish to use a smaller maximum allowed lifetime (perhaps as small as the default lifetime) to more quickly remove orphaned allocations (that is, allocations where the corresponding client has crashed or terminated, or the client connection has been lost for some reason). Also, note that the time- to-expiry is recomputed with each successful Refresh request, and thus, the value computed here applies only until the first refresh.

Once the allocation is created, the server replies with a success response. The success response contains:

[nobullet=false,spacing=normal]
* An XOR-RELAYED-ADDRESS attribute containing the relayed transport address or two XOR-RELAYED-ADDRESS attributes containing the relayed transport addresses.
* A LIFETIME attribute containing the current value of the time-to-expiry timer.
* A RESERVATION-TOKEN attribute (if a second relayed transport address was reserved).
* An XOR-MAPPED-ADDRESS attribute containing the client's IP address and port (from the 5-tuple).

NOTE: NOTE: The XOR-MAPPED-ADDRESS attribute is included in the response as a convenience to the client. TURN itself does not make use of this value, but clients running ICE can often need this value and can thus avoid having to do an extra Binding transaction with some STUN server to learn it.
The response (either success or error) is sent back to the client on the 5-tuple.

NOTE: NOTE: When the Allocate request is sent over UDP, <<RFC8489,format=default>> requires that the server handle the possible retransmissions of the request so that retransmissions do not cause multiple allocations to be created. Implementations may achieve this using the so-called "stateless stack approach" as follows. To detect retransmissions when the original request was successful in creating an allocation, the server can store the transaction id that created the request with the allocation data and compare it with incoming Allocate requests on the same 5-tuple. Once such a request is detected, the server can stop parsing the request and immediately generate a success response. When building this response, the value of the LIFETIME attribute can be taken from the time-to-expiry field in the allocate state data, even though this value may differ slightly from the LIFETIME value originally returned. In addition, the server may need to store an indication of any reservation token returned in the original response so that this may be returned in any retransmitted responses.
For the case where the original request was unsuccessful in creating an allocation, the server may choose to do nothing special. Note, however, that there is a rare case where the server rejects the original request but accepts the retransmitted request (because conditions have changed in the brief intervening time period). If the client receives the first failure response, it will ignore the second (success) response and believe that an allocation was not created. An allocation created in this manner will eventually time out since the client will not refresh it. Furthermore, if the client later retries with the same 5-tuple but a different transaction id, it will receive a 437 (Allocation Mismatch) error response, which will cause it to retry with a different 5-tuple. The server may use a smaller maximum lifetime value to minimize the lifetime of allocations "orphaned" in this manner.
[numbered=true,removeInRFC=false,toc=include]
=== Receiving an Allocate Success Response

If the client receives an Allocate success response, then it [bcp14]#MUST# check that the mapped address and the relayed transport address or addresses are part of an address family or families that the client understands and is prepared to handle. If these addresses are not part of an address family or families that the client is prepared to handle, then the client [bcp14]#MUST# delete the allocation (<<sec-refreshing-allocation,format=default>>) and [bcp14]#MUST NOT# attempt to create another allocation on that server until it believes the mismatch has been fixed.

Otherwise, the client creates its own copy of the allocation data structure to track what is happening on the server. In particular, the client needs to remember the actual lifetime received back from the server, rather than the value sent to the server in the request. The client must also remember the 5-tuple used for the request and the username and password it used to authenticate the request to ensure that it reuses them for subsequent messages. The client also needs to track the channels and permissions it establishes on the server.

If the client receives an Allocate success response but with an ADDRESS-ERROR-CODE attribute in the response and the error code value signaled in the ADDRESS-ERROR-CODE attribute is 440 (Address Family not Supported), the client [bcp14]#MUST NOT# retry its request for the rejected address type. If the client receives an ADDRESS-ERROR-CODE attribute in the response and the error code value signaled in the ADDRESS-ERROR-CODE attribute is 508 (Insufficient Capacity), the client [bcp14]#SHOULD# wait at least 1 minute before trying to request any more allocations on this server for the rejected address type.

The client will probably wish to send the relayed transport address to peers (using some method not specified here) so the peers can communicate with it. The client may also wish to use the server-reflexive address it receives in the XOR-MAPPED-ADDRESS attribute in its ICE processing.

[[sec-allocate-error-response]]
[numbered=true,removeInRFC=false,toc=include]
=== Receiving an Allocate Error Response

If the client receives an Allocate error response, then the processing depends on the actual error code returned:

[newline=true,spacing=normal]
408 (Request timed out)::: There is either a problem with the server or a problem reaching the server with the chosen transport. The client considers the current transaction as having failed but [bcp14]#MAY# choose to retry the Allocate request using a different transport (e.g., TCP instead of UDP).
300 (Try Alternate)::: The server would like the client to use the server specified in the ALTERNATE-SERVER attribute instead. The client considers the current transaction as having failed, but it [bcp14]#SHOULD# try the Allocate request with the alternate server before trying any other servers (e.g., other servers discovered using the DNS resolution procedures). When trying the Allocate request with the alternate server, the client follows the ALTERNATE-SERVER procedures specified in <<RFC8489,format=default>>.
400 (Bad Request)::: The server believes the client's request is malformed for some reason. The client considers the current transaction as having failed. The client [bcp14]#MAY# notify the user or operator and [bcp14]#SHOULD NOT# retry the request with this server until it believes the problem has been fixed.
401 (Unauthorized)::: If the client has followed the procedures of the long-term credential mechanism and still gets this error, then the server is not accepting the client's credentials. In this case, the client considers the current transaction as having failed and [bcp14]#SHOULD# notify the user or operator. The client [bcp14]#SHOULD NOT# send any further requests to this server until it believes the problem has been fixed.
403 (Forbidden)::: The request is valid, but the server is refusing to perform it, likely due to administrative restrictions. The client considers the current transaction as having failed. The client [bcp14]#MAY# notify the user or operator and [bcp14]#SHOULD NOT# retry the same request with this server until it believes the problem has been fixed.
420 (Unknown Attribute)::: If the client included a DONT-FRAGMENT attribute in the request and the server rejected the request with a 420 error code and listed the DONT-FRAGMENT attribute in the UNKNOWN-ATTRIBUTES attribute in the error response, then the client now knows that the server does not support the DONT-FRAGMENT attribute. The client considers the current transaction as having failed but [bcp14]#MAY# choose to retry the Allocate request without the DONT-FRAGMENT attribute.
437 (Allocation Mismatch)::: This indicates that the client has picked a 5-tuple that the server sees as already in use. One way this could happen is if an intervening NAT assigned a mapped transport address that was used by another client that recently crashed. The client considers the current transaction as having failed. The client [bcp14]#SHOULD# pick another client transport address and retry the Allocate request (using a different transaction id). The client [bcp14]#SHOULD# try three different client transport addresses before giving up on this server. Once the client gives up on the server, it [bcp14]#SHOULD NOT# try to create another allocation on the server for 2 minutes.
438 (Stale Nonce)::: See the procedures for the long-term credential mechanism <<RFC8489,format=default>>.
440 (Address Family not Supported)::: The server does not support the address family requested by the client. If the client receives an Allocate error response with the 440 (Address Family not Supported) error code, the client [bcp14]#MUST NOT# retry the request.
441 (Wrong Credentials)::: The client should not receive this error in response to an Allocate request. The client [bcp14]#MAY# notify the user or operator and [bcp14]#SHOULD NOT# retry the same request with this server until it believes the problem has been fixed.
442 (Unsupported Transport Address)::: The client should not receive this error in response to a request for a UDP allocation. The client [bcp14]#MAY# notify the user or operator and [bcp14]#SHOULD NOT# reattempt the request with this server until it believes the problem has been fixed.
486 (Allocation Quota Reached)::: The server is currently unable to create any more allocations with this username. The client considers the current transaction as having failed. The client [bcp14]#SHOULD# wait at least 1 minute before trying to create any more allocations on the server.
508 (Insufficient Capacity)::: The server has no more relayed transport addresses available or has none with the requested properties, or the one that was reserved is no longer available. The client considers the current operation as having failed. If the client is using either the EVEN-PORT or the RESERVATION-TOKEN attribute, then the client [bcp14]#MAY# choose to remove or modify this attribute and try again immediately. Otherwise, the client [bcp14]#SHOULD# wait at least 1 minute before trying to create any more allocations on this server.

Note that the error code values 486 and 508 indicate to a eavesdropper that several other users are using the server at this time, similar to that of the HTTP error response code 503, but it does not reveal any information about the users using the TURN server.

An unknown error response [bcp14]#MUST# be handled as described in <<RFC8489,format=default>>.

[[sec-refreshing-allocation]]
[numbered=true,removeInRFC=false,toc=include]
== Refreshing an Allocation

A Refresh transaction can be used to either (a) refresh an existing allocation and update its time-to-expiry or (b) delete an existing allocation.

If a client wishes to continue using an allocation, then the client [bcp14]#MUST# refresh it before it expires. It is suggested that the client refresh the allocation roughly 1 minute before it expires. If a client no longer wishes to use an allocation, then it [bcp14]#SHOULD# explicitly delete the allocation. A client [bcp14]#MAY# refresh an allocation at any time for other reasons.

[numbered=true,removeInRFC=false,toc=include]
=== Sending a Refresh Request

If the client wishes to immediately delete an existing allocation, it includes a LIFETIME attribute with a value of zero. All other forms of the request refresh the allocation.

When refreshing a dual allocation, the client includes a REQUESTED-ADDRESS-FAMILY attribute indicating the address family type that should be refreshed. If no REQUESTED-ADDRESS-FAMILY attribute is included, then the request should be treated as applying to all current allocations. The client [bcp14]#MUST# only include a family type it previously allocated and has not yet deleted. This process can also be used to delete an allocation of a specific address type by setting the lifetime of that Refresh request to zero. Deleting a single allocation destroys any permissions or channels associated with that particular allocation; it [bcp14]#MUST NOT# affect any permissions or channels associated with allocations for the other address family.

The Refresh transaction updates the time-to-expiry timer of an allocation. If the client wishes the server to set the time-to-expiry timer to something other than the default lifetime, it includes a LIFETIME attribute with the requested value. The server then computes a new time-to-expiry value in the same way as it does for an Allocate transaction, with the exception that a requested lifetime of zero causes the server to immediately delete the allocation.

[[sec-rcv-refresh]]
[numbered=true,removeInRFC=false,toc=include]
=== Receiving a Refresh Request

When the server receives a Refresh request, it processes the request as per <<sec-general-behavior,format=default>> plus the specific rules mentioned here.

If the server receives a Refresh Request with a REQUESTED-ADDRESS-FAMILY attribute and the attribute value does not match the address family of the allocation, the server [bcp14]#MUST# reply with a 443 (Peer Address Family Mismatch) Refresh error response.

The server computes a value called the "desired lifetime" as follows: if the request contains a LIFETIME attribute and the attribute value is zero, then the "desired lifetime" is zero. Otherwise, if the request contains a LIFETIME attribute, then the server computes the minimum of the client's requested lifetime and the server's maximum allowed lifetime. If this computed value is greater than the default lifetime, then the "desired lifetime" is the computed value. Otherwise, the "desired lifetime" is the default lifetime.

Subsequent processing depends on the "desired lifetime" value:

[nobullet=false,spacing=normal]
* If the "desired lifetime" is zero, then the request succeeds and the allocation is deleted.
* If the "desired lifetime" is non-zero, then the request succeeds and the allocation's time-to-expiry is set to the "desired lifetime".

If the request succeeds, then the server sends a success response containing:

[nobullet=false,spacing=normal]
* A LIFETIME attribute containing the current value of the time-to-expiry timer.

NOTE: NOTE: A server need not do anything special to implement idempotency of Refresh requests over UDP using the "stateless stack approach". Retransmitted Refresh requests with a non-zero "desired lifetime" will simply refresh the allocation. A retransmitted Refresh request with a zero "desired lifetime" will cause a 437 (Allocation Mismatch) response if the allocation has already been deleted, but the client will treat this as equivalent to a success response (see below).
[numbered=true,removeInRFC=false,toc=include]
=== Receiving a Refresh Response

If the client receives a success response to its Refresh request with a non-zero lifetime, it updates its copy of the allocation data structure with the time-to-expiry value contained in the response. If the client receives a 437 (Allocation Mismatch) error response to its request to refresh the allocation, it should consider the allocation no longer exists. If the client receives a 438 (Stale Nonce) error to its request to refresh the allocation, it should reattempt the request with the new nonce value.

If the client receives a 437 (Allocation Mismatch) error response to a request to delete the allocation, then the allocation no longer exists and it should consider its request as having effectively succeeded.

[[sec-permissions]]
[numbered=true,removeInRFC=false,toc=include]
== Permissions

For each allocation, the server keeps a list of zero or more permissions. Each permission consists of an IP address and an associated time-to-expiry. While a permission exists, all peers using the IP address in the permission are allowed to send data to the client. The time-to-expiry is the number of seconds until the permission expires. Within the context of an allocation, a permission is uniquely identified by its associated IP address.

By sending either CreatePermission requests or ChannelBind requests, the client can cause the server to install or refresh a permission for a given IP address. This causes one of two things to happen:

[nobullet=false,spacing=normal]
* If no permission for that IP address exists, then a permission is created with the given IP address and a time-to-expiry equal to Permission Lifetime.
* If a permission for that IP address already exists, then the time-to-expiry for that permission is reset to Permission Lifetime.

The Permission Lifetime [bcp14]#MUST# be 300 seconds (= 5 minutes).

Each permission's time-to-expiry decreases down once per second until it reaches zero, at which point, the permission expires and is deleted.

CreatePermission and ChannelBind requests may be freely intermixed on a permission. A given permission may be initially installed and/or refreshed with a CreatePermission request and then later refreshed with a ChannelBind request, or vice versa.

When a UDP datagram arrives at the relayed transport address for the allocation, the server extracts the source IP address from the IP header. The server then compares this address with the IP address associated with each permission in the list of permissions for the allocation. Note that only addresses are compared and port numbers are not considered. If no match is found, relaying is not permitted and the server silently discards the UDP datagram. If an exact match is found, the permission check is considered to have succeeded and the server continues to process the UDP datagram as specified elsewhere (<<sec-sending-data-indication,format=default>>).

The permissions for one allocation are totally unrelated to the permissions for a different allocation. If an allocation expires, all its permissions expire with it.

NOTE: NOTE: Though TURN permissions expire after 5 minutes, many NATs deployed at the time of publication expire their UDP bindings considerably faster. Thus, an application using TURN will probably wish to send some sort of keep-alive traffic at a much faster rate. Applications using ICE should follow the keep-alive guidelines of ICE <<RFC8445,format=default>>, and applications not using ICE are advised to do something similar.
[numbered=true,removeInRFC=false,toc=include]
== CreatePermission

TURN supports two ways for the client to install or refresh permissions on the server. This section describes one way: the CreatePermission request.

A CreatePermission request may be used in conjunction with either the Send mechanism in <<sec-sendanddata,format=default>> or the Channel mechanism in <<sec-channels,format=default>>.

[numbered=true,removeInRFC=false,toc=include]
=== Forming a CreatePermission Request

The client who wishes to install or refresh one or more permissions can send a CreatePermission request to the server.

When forming a CreatePermission request, the client [bcp14]#MUST# include at least one XOR-PEER-ADDRESS attribute and [bcp14]#MAY# include more than one such attribute. The IP address portion of each XOR-PEER-ADDRESS attribute contains the IP address for which a permission should be installed or refreshed. The port portion of each XOR-PEER-ADDRESS attribute will be ignored and can be any arbitrary value. The various XOR-PEER-ADDRESS attributes [bcp14]#MAY# appear in any order. The client [bcp14]#MUST# only include XOR-PEER-ADDRESS attributes with addresses of the same address family as that of the relayed transport address for the allocation. For dual allocations obtained using the ADDITIONAL-ADDRESS-FAMILY attribute, the client [bcp14]#MAY# include XOR-PEER-ADDRESS attributes with addresses of IPv4 and IPv6 address families.

[numbered=true,removeInRFC=false,toc=include]
=== Receiving a CreatePermission Request

When the server receives the CreatePermission request, it processes as per <<sec-general-behavior,format=default>> plus the specific rules mentioned here.

The message is checked for validity. The CreatePermission request [bcp14]#MUST# contain at least one XOR-PEER-ADDRESS attribute and [bcp14]#MAY# contain multiple such attributes. If no such attribute exists, or if any of these attributes are invalid, then a 400 (Bad Request) error is returned. If the request is valid, but the server is unable to satisfy the request due to some capacity limit or similar, then a 508 (Insufficient Capacity) error is returned.

If an XOR-PEER-ADDRESS attribute contains an address of an address family that is not the same as that of a relayed transport address for the allocation, the server [bcp14]#MUST# generate an error response with the 443 (Peer Address Family Mismatch) response code.

The server [bcp14]#MAY# impose restrictions on the IP address allowed in the XOR-PEER-ADDRESS attribute; if a value is not allowed, the server rejects the request with a 403 (Forbidden) error.

If the message is valid and the server is capable of carrying out the request, then the server installs or refreshes a permission for the IP address contained in each XOR-PEER-ADDRESS attribute as described in <<sec-permissions,format=default>>. The port portion of each attribute is ignored and may be any arbitrary value.

The server then responds with a CreatePermission success response. There are no mandatory attributes in the success response.

NOTE: NOTE: A server need not do anything special to implement idempotency of CreatePermission requests over UDP using the "stateless stack approach". Retransmitted CreatePermission requests will simply refresh the permissions.
[numbered=true,removeInRFC=false,toc=include]
=== Receiving a CreatePermission Response

If the client receives a valid CreatePermission success response, then the client updates its data structures to indicate that the permissions have been installed or refreshed.

[[sec-sendanddata]]
[numbered=true,removeInRFC=false,toc=include]
== Send and Data Methods

TURN supports two mechanisms for sending and receiving data from peers. This section describes the use of the Send and Data mechanisms, while <<sec-channels,format=default>> describes the use of the Channel mechanism.

[[sec-forming-indication]]
[numbered=true,removeInRFC=false,toc=include]
=== Forming a Send Indication

The client can use a Send indication to pass data to the server for relaying to a peer. A client may use a Send indication even if a channel is bound to that peer. However, the client [bcp14]#MUST# ensure that there is a permission installed for the IP address of the peer to which the Send indication is being sent; this prevents a third party from using a TURN server to send data to arbitrary destinations.

When forming a Send indication, the client [bcp14]#MUST# include an XOR-PEER-ADDRESS attribute and a DATA attribute. The XOR-PEER-ADDRESS attribute contains the transport address of the peer to which the data is to be sent, and the DATA attribute contains the actual application data to be sent to the peer.

The client [bcp14]#MAY# include a DONT-FRAGMENT attribute in the Send indication if it wishes the server to set the DF bit on the UDP datagram sent to the peer.

[numbered=true,removeInRFC=false,toc=include]
=== Receiving a Send Indication

When the server receives a Send indication, it processes as per <<sec-general-behavior,format=default>> plus the specific rules mentioned here.

The message is first checked for validity. The Send indication [bcp14]#MUST# contain both an XOR-PEER-ADDRESS attribute and a DATA attribute. If one of these attributes is missing or invalid, then the message is discarded. Note that the DATA attribute is allowed to contain zero bytes of data.

The Send indication may also contain the DONT-FRAGMENT attribute. If the server is unable to set the DF bit on outgoing UDP datagrams when this attribute is present, then the server acts as if the DONT-FRAGMENT attribute is an unknown comprehension-required attribute (and thus the Send indication is discarded).

The server also checks that there is a permission installed for the IP address contained in the XOR-PEER-ADDRESS attribute. If no such permission exists, the message is discarded. Note that a Send indication never causes the server to refresh the permission.

The server [bcp14]#MAY# impose restrictions on the IP address and port values allowed in the XOR-PEER-ADDRESS attribute; if a value is not allowed, the server silently discards the Send indication.

If everything is OK, then the server forms a UDP datagram as follows:

[nobullet=false,spacing=normal]
* the source transport address is the relayed transport address of the allocation, where the allocation is determined by the 5-tuple on which the Send indication arrived;
* the destination transport address is taken from the XOR-PEER-ADDRESS attribute;
* the data following the UDP header is the contents of the value field of the DATA attribute.

The handling of the DONT-FRAGMENT attribute (if present), is described in Sections <<sec-ip-header-fields,format=counter>> and <<sec-ip-header-fields-tcp-udp,format=counter>>.

The resulting UDP datagram is then sent to the peer.

[[sec-sending-data-indication]]
[numbered=true,removeInRFC=false,toc=include]
=== Receiving a UDP Datagram

When the server receives a UDP datagram at a currently allocated relayed transport address, the server looks up the allocation associated with the relayed transport address. The server then checks to see whether the set of permissions for the allocation allow the relaying of the UDP datagram as described in <<sec-permissions,format=default>>.

If relaying is permitted, then the server checks if there is a channel bound to the peer that sent the UDP datagram (see <<sec-channels,format=default>>). If a channel is bound, then processing proceeds as described in <<sec-channel-relaying,format=default>>.

If relaying is permitted but no channel is bound to the peer, then the server forms and sends a Data indication. The Data indication [bcp14]#MUST# contain both an XOR-PEER-ADDRESS and a DATA attribute. The DATA attribute is set to the value of the "data octets" field from the datagram, and the XOR-PEER-ADDRESS attribute is set to the source transport address of the received UDP datagram. The Data indication is then sent on the 5-tuple associated with the allocation.

[numbered=true,removeInRFC=false,toc=include]
=== Receiving a Data Indication

When the client receives a Data indication, it checks that the Data indication contains an XOR-PEER-ADDRESS attribute and discards the indication if it does not. The client [bcp14]#SHOULD# also check that the XOR-PEER-ADDRESS attribute value contains an IP address with which the client believes there is an active permission and discard the Data indication otherwise.

NOTE: NOTE: The latter check protects the client against an attacker who somehow manages to trick the server into installing permissions not desired by the client.
If the XOR-PEER-ADDRESS is present and valid, the client checks that the Data indication contains either a DATA attribute or an ICMP attribute and discards the indication if it does not. Note that a DATA attribute is allowed to contain zero bytes of data. Processing of Data indications with an ICMP attribute is described in <<receive-senderror,format=default>>.

If the Data indication passes the above checks, the client delivers the data octets inside the DATA attribute to the application, along with an indication that they were received from the peer whose transport address is given by the XOR-PEER-ADDRESS attribute.

[[sec-sending-senderror-indication]]
[numbered=true,removeInRFC=false,toc=include]
=== Receiving an ICMP Packet

When the server receives an ICMP packet, the server verifies that the type is either 3 or 11 for an ICMPv4 <<RFC0792,format=default>> packet or either 1, 2, or 3 for an ICMPv6 <<RFC4443,format=default>> packet. It also verifies that the IP packet in the ICMP packet payload contains a UDP header. If either of these conditions fail, then the ICMP packet is silently dropped. If a UDP header is present, the server extracts the source and destination IP address and UDP port information.

The server looks up the allocation whose relayed transport address corresponds to the encapsulated packet's source IP address and UDP port. If no such allocation exists, the packet is silently dropped. The server then checks to see whether the set of permissions for the allocation allows the relaying of the ICMP packet. For ICMP packets, the source IP address [bcp14]#MUST NOT# be checked against the permissions list as it would be for UDP packets. Instead, the server extracts the destination IP address from the encapsulated IP header. The server then compares this address with the IP address associated with each permission in the list of permissions for the allocation. If no match is found, relaying is not permitted and the server silently discards the ICMP packet. Note that only addresses are compared and port numbers are not considered.

If relaying is permitted, then the server forms and sends a Data indication. The Data indication [bcp14]#MUST# contain both an XOR-PEER-ADDRESS and an ICMP attribute. The ICMP attribute is set to the value of the type and code fields from the ICMP packet. The IP address portion of XOR-PEER-ADDRESS attribute is set to the destination IP address in the encapsulated IP header. At the time of writing of this specification, Socket APIs on some operating systems do not deliver the destination port in the encapsulated UDP header to applications without superuser privileges. If destination port in the encapsulated UDP header is available to the server, then the port portion of the XOR-PEER-ADDRESS attribute is set to the destination port; otherwise, the port portion is set to zero. The Data indication is then sent on the 5-tuple associated with the allocation.

NOTE: Implementation Note: New ICMP types or codes can be defined in future specifications. If the server receives an ICMP error packet, and the new type or code field can help the client to make use of the ICMP error notification and generate feedback to the application layer, the server sends the Data indication with an ICMP attribute conveying the new ICMP type or code.
[[receive-senderror]]
[numbered=true,removeInRFC=false,toc=include]
=== Receiving a Data Indication with an ICMP Attribute

When the client receives a Data indication with an ICMP attribute, it checks that the Data indication contains an XOR-PEER-ADDRESS attribute and discards the indication if it does not. The client [bcp14]#SHOULD# also check that the XOR-PEER-ADDRESS attribute value contains an IP address with an active permission and discard the Data indication otherwise.

If the Data indication passes the above checks, the client signals the application of the error condition along with an indication that it was received from the peer whose transport address is given by the XOR-PEER-ADDRESS attribute. The application can make sense of the meaning of the type and code values in the ICMP attribute by using the family field in the XOR-PEER-ADDRESS attribute.

[[sec-channels]]
[numbered=true,removeInRFC=false,toc=include]
== Channels

Channels provide a way for the client and server to send application data using ChannelData messages, which have less overhead than Send and Data indications.

The ChannelData message (see <<sec-channeldata-msg,format=default>>) starts with a two-byte field that carries the channel number. The values of this field are allocated as follows:

[[channels]]
[align=center]
|===
|0x0000 through 0x3FFF: | These values can never be used for channel numbers.
|0x4000 through 0x4FFF: | These values are the allowed channel numbers (4096 possible values).
|0x5000 through 0xFFFF: | Reserved (For DTLS-SRTP multiplexing collision avoidance, see <<RFC7983,format=default>>).
|===

Note that the channel number range is not backwards compatible with <<RFC5766,format=default>>, which could prevent a client compliant with RFC 5766 from establishing channel bindings with a TURN server that complies with this specification.

According to <<RFC7983,format=default>>, ChannelData messages can be distinguished from other multiplexed protocols by examining the first byte of the message:

[[fig-demultiplexing]]
[align=center]
|===
|[0..3] | STUN
|[16..19] | ZRTP
|[20..63] | DTLS
|[64..79] | TURN Channel
|[128..191] | RTP/RTCP
|Others | Reserved; [bcp14]#MUST# be dropped and an alert [bcp14]#MAY# be logged
|===

Reserved values may be used in the future by other protocols. When the client uses channel binding, it [bcp14]#MUST# comply with the demultiplexing scheme discussed above.

Channel bindings are always initiated by the client. The client can bind a channel to a peer at any time during the lifetime of the allocation. The client may bind a channel to a peer before exchanging data with it or after exchanging data with it (using Send and Data indications) for some time, or may choose never to bind a channel to it. The client can also bind channels to some peers while not binding channels to other peers.

Channel bindings are specific to an allocation so that the use of a channel number or peer transport address in a channel binding in one allocation has no impact on their use in a different allocation. If an allocation expires, all its channel bindings expire with it.

A channel binding consists of:

[nobullet=false,spacing=normal]
* a channel number;
* a transport address (of the peer); and
* A time-to-expiry timer.

Within the context of an allocation, a channel binding is uniquely identified either by the channel number or by the peer's transport address. Thus, the same channel cannot be bound to two different transport addresses, nor can the same transport address be bound to two different channels.

A channel binding lasts for 10 minutes unless refreshed. Refreshing the binding (by the server receiving a ChannelBind request rebinding the channel to the same peer) resets the time-to-expiry timer back to 10 minutes.

When the channel binding expires, the channel becomes unbound. Once unbound, the channel number can be bound to a different transport address, and the transport address can be bound to a different channel number. To prevent race conditions, the client [bcp14]#MUST# wait 5 minutes after the channel binding expires before attempting to bind the channel number to a different transport address or the transport address to a different channel number.

When binding a channel to a peer, the client [bcp14]#SHOULD# be prepared to receive ChannelData messages on the channel from the server as soon as it has sent the ChannelBind request. Over UDP, it is possible for the client to receive ChannelData messages from the server before it receives a ChannelBind success response.

In the other direction, the client [bcp14]#MAY# elect to send ChannelData messages before receiving the ChannelBind success response. Doing so, however, runs the risk of having the ChannelData messages dropped by the server if the ChannelBind request does not succeed for some reason (e.g., packet lost if the request is sent over UDP or the server being unable to fulfill the request). A client that wishes to be safe should either queue the data or use Send indications until the channel binding is confirmed.

[numbered=true,removeInRFC=false,toc=include]
=== Sending a ChannelBind Request

A channel binding is created or refreshed using a ChannelBind transaction. A ChannelBind transaction also creates or refreshes a permission towards the peer (see <<sec-permissions,format=default>>).

To initiate the ChannelBind transaction, the client forms a ChannelBind request. The channel to be bound is specified in a CHANNEL-NUMBER attribute, and the peer's transport address is specified in an XOR-PEER-ADDRESS attribute. <<sec-receiving-ChannelBind,format=default>> describes the restrictions on these attributes. The client [bcp14]#MUST# only include an XOR-PEER-ADDRESS attribute with an address of the same address family as that of a relayed transport address for the allocation.

Rebinding a channel to the same transport address that it is already bound to provides a way to refresh a channel binding and the corresponding permission without sending data to the peer. Note, however, that permissions need to be refreshed more frequently than channels.

[[sec-receiving-ChannelBind]]
[numbered=true,removeInRFC=false,toc=include]
=== Receiving a ChannelBind Request

When the server receives a ChannelBind request, it processes as per <<sec-general-behavior,format=default>> plus the specific rules mentioned here.

The server checks the following:

[nobullet=false,spacing=normal]
* The request contains both a CHANNEL-NUMBER and an XOR-PEER-ADDRESS attribute;
* The channel number is in the range 0x4000 through 0x4FFF (inclusive);
* The channel number is not currently bound to a different transport address (same transport address is OK);
* The transport address is not currently bound to a different channel number.

If any of these tests fail, the server replies with a 400 (Bad Request) error. If the XOR-PEER-ADDRESS attribute contains an address of an address family that is not the same as that of a relayed transport address for the allocation, the server [bcp14]#MUST# generate an error response with the 443 (Peer Address Family Mismatch) response code.

The server [bcp14]#MAY# impose restrictions on the IP address and port values allowed in the XOR-PEER-ADDRESS attribute; if a value is not allowed, the server rejects the request with a 403 (Forbidden) error.

If the request is valid, but the server is unable to fulfill the request due to some capacity limit or similar, the server replies with a 508 (Insufficient Capacity) error.

Otherwise, the server replies with a ChannelBind success response. There are no required attributes in a successful ChannelBind response.

If the server can satisfy the request, then the server creates or refreshes the channel binding using the channel number in the CHANNEL-NUMBER attribute and the transport address in the XOR-PEER-ADDRESS attribute. The server also installs or refreshes a permission for the IP address in the XOR-PEER-ADDRESS attribute as described in <<sec-permissions,format=default>>.

NOTE: NOTE: A server need not do anything special to implement idempotency of ChannelBind requests over UDP using the "stateless stack approach". Retransmitted ChannelBind requests will simply refresh the channel binding and the corresponding permission. Furthermore, the client must wait 5 minutes before binding a previously bound channel number or peer address to a different channel, eliminating the possibility that the transaction would initially fail but succeed on a retransmission.
[numbered=true,removeInRFC=false,toc=include]
=== Receiving a ChannelBind Response

When the client receives a ChannelBind success response, it updates its data structures to record that the channel binding is now active. It also updates its data structures to record that the corresponding permission has been installed or refreshed.

If the client receives a ChannelBind failure response that indicates that the channel information is out of sync between the client and the server (e.g., an unexpected 400 "Bad Request" response), then it is [bcp14]#RECOMMENDED# that the client immediately delete the allocation and start afresh with a new allocation.

[[sec-channeldata-msg]]
[numbered=true,removeInRFC=false,toc=include]
=== The ChannelData Message

The ChannelData message is used to carry application data between the client and the server. It has the following format:

[suppress-title=false,align=left,alt=]
[align=left,alt=,]
....
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Channel Number        |            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
/                       Application Data                        /
/                                                               /
|                                                               |
|                               +-------------------------------+
|                               |
+-------------------------------+
....

The Channel Number field specifies the number of the channel on which the data is traveling, and thus, the address of the peer that is sending or is to receive the data.

The Length field specifies the length in bytes of the application data field (i.e., it does not include the size of the ChannelData header). Note that 0 is a valid length.

The Application Data field carries the data the client is trying to send to the peer, or that the peer is sending to the client.

[[sec-sending-channeldata-msg]]
[numbered=true,removeInRFC=false,toc=include]
=== Sending a ChannelData Message

Once a client has bound a channel to a peer, then when the client has data to send to that peer, it may use either a ChannelData message or a Send indication; that is, the client is not obligated to use the channel when it exists and may freely intermix the two message types when sending data to the peer. The server, on the other hand, [bcp14]#MUST# use the ChannelData message if a channel has been bound to the peer. The server uses a Data indication to signal the XOR-PEER-ADDRESS and ICMP attributes to the client even if a channel has been bound to the peer.

The fields of the ChannelData message are filled in as described in <<sec-channeldata-msg,format=default>>.

Over TCP and TLS-over-TCP, the ChannelData message [bcp14]#MUST# be padded to a multiple of four bytes in order to ensure the alignment of subsequent messages. The padding is not reflected in the length field of the ChannelData message, so the actual size of a ChannelData message (including padding) is (4 + Length) rounded up to the nearest multiple of 4 (see <<RFC8489,format=default>>). Over UDP, the padding is not required but [bcp14]#MAY# be included.

The ChannelData message is then sent on the 5-tuple associated with the allocation.

[numbered=true,removeInRFC=false,toc=include]
=== Receiving a ChannelData Message

The receiver of the ChannelData message uses the first byte to distinguish it from other multiplexed protocols as described in <<fig-demultiplexing,format=default>>. If the message uses a value in the reserved range (0x5000 through 0xFFFF), then the message is silently discarded.

If the ChannelData message is received in a UDP datagram, and if the UDP datagram is too short to contain the claimed length of the ChannelData message (i.e., the UDP header length field value is less than the ChannelData header length field value + 4 + 8), then the message is silently discarded.

If the ChannelData message is received over TCP or over TLS-over-TCP, then the actual length of the ChannelData message is as described in <<sec-sending-channeldata-msg,format=default>>.

If the ChannelData message is received on a channel that is not bound to any peer, then the message is silently discarded.

On the client, it is [bcp14]#RECOMMENDED# that the client discard the ChannelData message if the client believes there is no active permission towards the peer. On the server, the receipt of a ChannelData message [bcp14]#MUST NOT# refresh either the channel binding or the permission towards the peer.

On the server, if no errors are detected, the server relays the application data to the peer by forming a UDP datagram as follows:

[nobullet=false,spacing=normal]
* the source transport address is the relayed transport address of the allocation, where the allocation is determined by the 5-tuple on which the ChannelData message arrived;
* the destination transport address is the transport address to which the channel is bound;
* the data following the UDP header is the contents of the data field of the ChannelData message.

The resulting UDP datagram is then sent to the peer. Note that if the Length field in the ChannelData message is 0, then there will be no data in the UDP datagram, but the UDP datagram is still formed and sent (<<RFC6263,format=default>>).

[[sec-channel-relaying]]
[numbered=true,removeInRFC=false,toc=include]
=== Relaying Data from the Peer

When the server receives a UDP datagram on the relayed transport address associated with an allocation, the server processes it as described in <<sec-sending-data-indication,format=default>>. If that section indicates that a ChannelData message should be sent (because there is a channel bound to the peer that sent to the UDP datagram), then the server forms and sends a ChannelData message as described in <<sec-sending-channeldata-msg,format=default>>.

When the server receives an ICMP packet, the server processes it as described in <<sec-sending-senderror-indication,format=default>>.

[numbered=true,removeInRFC=false,toc=include]
== Packet Translations

This section addresses IPv4-to-IPv6, IPv6-to-IPv4, and IPv6-to-IPv6 translations. Requirements for translation of the IP addresses and port numbers of the packets are described above. The following sections specify how to translate other header fields.

As discussed in <<unpriv,format=default>>, translations in TURN are designed so that a TURN server can be implemented as an application that runs in user space under commonly available operating systems and that does not require special privileges. The translations specified in the following sections follow this principle.

The descriptions below have two parts: a preferred behavior and an alternate behavior. The server [bcp14]#SHOULD# implement the preferred behavior, but if that is not possible for a particular field, the server [bcp14]#MUST# implement the alternate behavior and [bcp14]#MUST NOT# do anything else for the reasons detailed in <<RFC7915,format=default>>. The TURN server solely relies on the DF bit in the IPv4 header and the Fragment header in the IPv6 header to handle fragmentation using the approach described in <<RFC7915,format=default>> and does not rely on the DONT-FRAGMENT attribute; ignoring the DONT-FRAGMENT attribute is only applicable for UDP-to-UDP relay and not for TCP-to-UDP relay.

[numbered=true,removeInRFC=false,toc=include]
=== IPv4-to-IPv6 Translations

Time to Live (TTL) field

[nobullet=true,spacing=normal]
* Preferred Behavior: As specified in<<RFC7915,format=default>>.
* Alternate Behavior: Set the outgoing value to the default for outgoing packets.

Traffic Class

[nobullet=true,spacing=normal]
* Preferred behavior: As specified in<<RFC7915,format=default>>.
* Alternate behavior: The TURN server sets the Traffic Class to the default value for outgoing packets.

Flow Label

[nobullet=true,spacing=normal]
* Preferred behavior: The TURN server can use the 5-tuple of relayed transport address, peer transport address, and UDP protocol number to identify each flow and to generate and set the flow label value in the IPv6 packet as discussed in<<RFC6437,format=default>>. If the TURN server is incapable of generating the flow label value from the IPv6 packet's 5-tuple, it sets the Flow label to zero.
* Alternate behavior: The alternate behavior is the same as the preferred behavior for a TURN server that does not support flow labels.

Hop Limit

[nobullet=true,spacing=normal]
* Preferred behavior: As specified in<<RFC7915,format=default>>.
* Alternate behavior: The TURN server sets the Hop Limit to the default value for outgoing packets.

Fragmentation

[nobullet=true,spacing=normal]
* Preferred behavior: As specified in<<RFC7915,format=default>>.
* Alternate behavior: The TURN server assembles incoming fragments. The TURN server follows its default behavior to send outgoing packets.
* For both preferred and alternate behavior, the DONT-FRAGMENT attribute[bcp14]#MUST#be ignored by the server.

Extension Headers

[nobullet=true,spacing=normal]
* Preferred behavior: The outgoing packet uses the system defaults for IPv6 extension headers, with the exception of the Fragment header as described above.
* Alternate behavior: Same as preferred.

[numbered=true,removeInRFC=false,toc=include]
=== IPv6-to-IPv6 Translations

Flow Label

NOTE: The TURN server should consider that it is handling two different IPv6 flows. Therefore, the Flow label <<RFC6437,format=default>>[bcp14]#SHOULD NOT# be copied as part of the translation.

[nobullet=true,spacing=normal]
* Preferred behavior: The TURN server can use the 5-tuple of relayed transport address, peer transport address, and UDP protocol number to identify each flow and to generate and set the flow label value in the IPv6 packet as discussed in<<RFC6437,format=default>>. If the TURN server is incapable of generating the flow label value from the IPv6 packet's 5-tuple, it sets the Flow label to zero.
* Alternate behavior: The alternate behavior is the same as the preferred behavior for a TURN server that does not support flow labels.

Hop Limit

[nobullet=true,spacing=normal]
* Preferred behavior: The TURN server acts as a regular router with respect to decrementing the Hop Limit and generating an ICMPv6 error if it reaches zero.
* Alternate behavior: The TURN server sets the Hop Limit to the default value for outgoing packets.

Fragmentation

[nobullet=true,spacing=normal]
* Preferred behavior: If the incoming packet did not include a Fragment header and the outgoing packet size does not exceed the outgoing link's MTU, the TURN server sends the outgoing packet without a Fragment header.
* If the incoming packet did not include a Fragment header and the outgoing packet size exceeds the outgoing link's MTU, the TURN server drops the outgoing packet and sends an ICMP message of type 2 code 0 ("Packet too big") to the sender of the incoming packet. If the ICMPv6 packet ("Packet too big") is being sent to the peer, the TURN server[bcp14]#SHOULD#reduce the MTU reported in the ICMP message by 48 bytes to allow room for the overhead of a Data indication.
* If the incoming packet included a Fragment header and the outgoing packet size (with a Fragment header included) does not exceed the outgoing link's MTU, the TURN server sends the outgoing packet with a Fragment header. The TURN server sets the fields of the Fragment header as appropriate for a packet originating from the server.
* If the incoming packet included a Fragment header and the outgoing packet size exceeds the outgoing link's MTU, the TURN server[bcp14]#MUST#fragment the outgoing packet into fragments of no more than 1280 bytes. The TURN server sets the fields of the Fragment header as appropriate for a packet originating from the server.
* Alternate behavior: The TURN server assembles incoming fragments. The TURN server follows its default behavior to send outgoing packets.
* For both preferred and alternate behavior, the DONT-FRAGMENT attribute[bcp14]#MUST#be ignored by the server.

Extension Headers

[nobullet=true,spacing=normal]
* Preferred behavior: The outgoing packet uses the system defaults for IPv6 extension headers, with the exception of the Fragment header as described above.
* Alternate behavior: Same as preferred.

[numbered=true,removeInRFC=false,toc=include]
=== IPv6-to-IPv4 Translations

Type of Service and Precedence

[nobullet=true,spacing=normal]
* Preferred behavior: As specified in<<RFC7915,format=default>>.
* Alternate behavior: The TURN server sets the Type of Service and Precedence to the default value for outgoing packets.

Time to Live

[nobullet=true,spacing=normal]
* Preferred behavior: As specified in<<RFC7915,format=default>>.
* Alternate behavior: The TURN server sets the Time to Live to the default value for outgoing packets.

Fragmentation

[nobullet=true,spacing=normal]
* Preferred behavior: As specified in<<RFC7915,format=default>>. Additionally, when the outgoing packet's size exceeds the outgoing link's MTU, the TURN server needs to generate an ICMP error (ICMPv6 "Packet too big") reporting the MTU size. If the ICMPv4 packet (Destination Unreachable (Type 3) with Code 4) is being sent to the peer, the TURN server[bcp14]#SHOULD#reduce the MTU reported in the ICMP message by 48 bytes to allow room for the overhead of a Data indication.
* Alternate behavior: The TURN server assembles incoming fragments. The TURN server follows its default behavior to send outgoing packets.
* For both preferred and alternate behavior, the DONT-FRAGMENT attribute[bcp14]#MUST#be ignored by the server.

[[sec-ip-header-fields]]
[numbered=true,removeInRFC=false,toc=include]
== UDP-to-UDP Relay

This section describes how the server sets various fields in the IP header for UDP-to-UDP relay from the client to the peer or vice versa. The descriptions in this section apply (a) when the server sends a UDP datagram to the peer or (b) when the server sends a Data indication or ChannelData message to the client over UDP transport. The descriptions in this section do not apply to TURN messages sent over TCP or TLS transport from the server to the client.

The descriptions below have two parts: a preferred behavior and an alternate behavior. The server [bcp14]#SHOULD# implement the preferred behavior, but if that is not possible for a particular field, then it [bcp14]#SHOULD# implement the alternative behavior.

Differentiated Services Code Point (DSCP) field <<RFC2474,format=default>>

[nobullet=true,spacing=normal]
* Preferred Behavior: Set the outgoing value to the incoming value unless the server includes a differentiated services classifier and marker<<RFC2474,format=default>>.
* Alternate Behavior: Set the outgoing value to a fixed value, which by default is Best Effort unless configured otherwise.
* In both cases, if the server is immediately adjacent to a differentiated services classifier and marker, then DSCP[bcp14]#MAY#be set to any arbitrary value in the direction towards the classifier.

Explicit Congestion Notification (ECN) field <<RFC3168,format=default>>

[nobullet=true,spacing=normal]
* Preferred Behavior: Set the outgoing value to the incoming value. The server may perform Active Queue Management, in which case it[bcp14]#SHOULD#behave as an ECN-aware router<<RFC3168,format=default>>and can mark traffic with Congestion Experienced (CE) instead of dropping the packet. The use of ECT(1) is subject to experimental usage<<RFC8311,format=default>>.
* Alternate Behavior: Set the outgoing value to Not-ECT (=0b00).

IPv4 Fragmentation fields (applicable only for IPv4-to-IPv4 relay)

[nobullet=true,spacing=normal]
* Preferred Behavior: When the server sends a packet to a peer in response to a Send indication containing the DONT-FRAGMENT attribute, then set the outgoing UDP packet to not fragment. In all other cases, when sending an outgoing packet containing application data (e.g., Data indication, a ChannelData message, or the DONT-FRAGMENT attribute not included in the Send indication), copy the DF bit from the DF bit of the incoming packet that contained the application data.
* Set the other fragmentation fields (Identification, More Fragments, Fragment Offset) as appropriate for a packet originating from the server.
* Alternate Behavior: As described in the Preferred Behavior, except always assume the incoming DF bit is 0.
* In both the Preferred and Alternate Behaviors, the resulting packet may be too large for the outgoing link. If this is the case, then the normal fragmentation rules apply<<RFC1122,format=default>>.

IPv4 Options

[nobullet=true,spacing=normal]
* Preferred Behavior: The outgoing packet uses the system defaults for IPv4 options.
* Alternate Behavior: Same as preferred.

[[sec-ip-header-fields-tcp-udp]]
[numbered=true,removeInRFC=false,toc=include]
== TCP-to-UDP Relay

This section describes how the server sets various fields in the IP header for TCP-to-UDP relay from the client to the peer. The descriptions in this section apply when the server sends a UDP datagram to the peer. Note that the server does not perform per-packet translation for TCP-to-UDP relaying.

Multipath TCP <<I-D.ietf-mptcp-rfc6824bis,format=default: TCP-EXT>> is not supported by this version of TURN because TCP multipath is not used by either SIP or WebRTC protocols <<RFC7478,format=default>> for media and non-media data. TCP connection between the TURN client and server can use the TCP Authentication Option (TCP-AO) <<RFC5925,format=default>>, but UDP does not provide a similar type of authentication, though it might be added in the future <<I-D.ietf-tsvwg-udp-options,format=default: UDP-OPT>>. Even if both TCP-AO and UDP authentication would be used between TURN client and server, it would not change the end-to-end security properties of the application payload being relayed. Therefore, applications using TURN will need to secure their application data end to end appropriately, e.g., Secure Real-time Transport Protocol (SRTP) for RTP applications. Note that the TCP-AO option obsoletes the TCP MD5 option.

Unlike UDP, TCP without the TCP Fast Open extension <<RFC7413,format=default>> does not support 0-RTT session resumption. The TCP user timeout <<RFC5482,format=default>> equivalent for application data relayed by the TURN is the use of RTP control protocol (RTCP). As a reminder, RTCP is a fundamental and integral part of RTP.

The descriptions below have two parts: a preferred behavior and an alternate behavior. The server [bcp14]#SHOULD# implement the preferred behavior, but if that is not possible for a particular field, then it [bcp14]#SHOULD# implement the alternative behavior.

For the UDP datagram sent to the peer based on a Send Indication or ChannelData message arriving at the TURN server over a TCP Transport, the server sets various fields in the IP header as follows:

Differentiated Services Code Point (DSCP) field <<RFC2474,format=default>>

[nobullet=true,spacing=normal]
* Preferred Behavior: The TCP connection can only use a single DSCP, so inter-flow differentiation is not possible; see<<RFC7657,format=default>>. The server sets the outgoing value to the DSCP used by the TCP connection, unless the server includes a differentiated services classifier and marker<<RFC2474,format=default>>.
* Alternate Behavior: Set the outgoing value to a fixed value, which by default is Best Effort unless configured otherwise.
* In both cases, if the server is immediately adjacent to a differentiated services classifier and marker, then DSCP[bcp14]#MAY#be set to any arbitrary value in the direction towards the classifier.

Explicit Congestion Notification (ECN) field <<RFC3168,format=default>>

[nobullet=true,spacing=normal]
* Preferred Behavior: No mechanism is defined to indicate what ECN value should be used for the outgoing UDP datagrams of an allocation; therefore, set the outgoing value to Not-ECT (=0b00).
* Alternate Behavior: Same as preferred.

IPv4 Fragmentation fields (applicable only for IPv4-to-IPv4 relay)

[nobullet=true,spacing=normal]
* Preferred Behavior: When the server sends a packet to a peer in response to a Send indication containing the DONT-FRAGMENT attribute, set the outgoing UDP packet to not fragment. In all other cases, when sending an outgoing UDP packet containing application data (e.g., Data indication, ChannelData message, or DONT-FRAGMENT attribute not included in the Send indication), set the DF bit in the outgoing IP header to 0.
* Alternate Behavior: Same as preferred.

IPv6 Fragmentation fields

[nobullet=true,spacing=normal]
* Preferred Behavior: If the TCP traffic arrives over IPv6, the server relies on the presence of the DONT-FRAGMENT attribute in the send indication to set the outgoing UDP packet to not fragment.
* Alternate Behavior: Same as preferred.

IPv4 Options

[nobullet=true,spacing=normal]
* Preferred Behavior: The outgoing packet uses the system defaults for IPv4 options.
* Alternate Behavior: Same as preferred.

[[UDP-to-TCP]]
[numbered=true,removeInRFC=false,toc=include]
== UDP-to-TCP Relay

This section describes how the server sets various fields in the IP header for UDP-to-TCP relay from the peer to the client. The descriptions in this section apply when the server sends a Data indication or ChannelData message to the client over TCP or TLS transport. Note that the server does not perform per-packet translation for UDP-to-TCP relaying.

The descriptions below have two parts: a preferred behavior and an alternate behavior. The server [bcp14]#SHOULD# implement the preferred behavior, but if that is not possible for a particular field, then it [bcp14]#SHOULD# implement the alternative behavior.

The TURN server sets IP header fields in the TCP packets on a per-connection basis for the TCP connection as follows:

Differentiated Services Code Point (DSCP) field <<RFC2474,format=default>>

[nobullet=true,spacing=normal]
* Preferred Behavior: Ignore the incoming DSCP value. When TCP is used between the client and the server, a single DSCP should be used for all traffic on that TCP connection. Note, TURN/ICE occurs before application data is exchanged.
* Alternate Behavior: Same as preferred.

Explicit Congestion Notification (ECN) field <<RFC3168,format=default>>

[nobullet=true,spacing=normal]
* Preferred Behavior: Ignore; ECN signals are dropped in the TURN server for the incoming UDP datagrams from the peer.
* Alternate Behavior: Same as preferred.

Fragmentation

[nobullet=true,spacing=normal]
* Preferred Behavior: Any fragmented packets are reassembled in the server and then forwarded to the client over the TCP connection. ICMP messages resulting from the UDP datagrams sent to the peer are processed by the server as described in<<sec-sending-senderror-indication,format=default>>and forwarded to the client using TURN's mechanism for relevant ICMP types and codes.
* Alternate Behavior: Same as preferred.

Extension Headers

[nobullet=true,spacing=normal]
* Preferred behavior: The outgoing packet uses the system defaults for IPv6 extension headers.
* Alternate behavior: Same as preferred.

IPv4 Options

[nobullet=true,spacing=normal]
* Preferred Behavior: The outgoing packet uses the system defaults for IPv4 options.
* Alternate Behavior: Same as preferred.

[[sec-stun-methods]]
[numbered=true,removeInRFC=false,toc=include]
== STUN Methods

This section lists the code points for the STUN methods defined in this specification. See elsewhere in this document for the semantics of these methods.

[[stun-methods]]
[align=center]
|===
|0x003 | Allocate | (only request/response semantics defined)
|0x004 | Refresh | (only request/response semantics defined)
|0x006 | Send | (only indication semantics defined)
|0x007 | Data | (only indication semantics defined)
|0x008 | CreatePermission | (only request/response semantics defined)
|0x009 | ChannelBind | (only request/response semantics defined)
|===

[[sec-stun-attributes]]
[numbered=true,removeInRFC=false,toc=include]
== STUN Attributes

This STUN extension defines the following attributes:

[[stun-attributes]]
[align=center]
|===
|0x000C | CHANNEL-NUMBER
|0x000D | LIFETIME
|0x0010 | Reserved (was BANDWIDTH)
|0x0012 | XOR-PEER-ADDRESS
|0x0013 | DATA
|0x0016 | XOR-RELAYED-ADDRESS
|0x0017 | REQUESTED-ADDRESS-FAMILY
|0x0018 | EVEN-PORT
|0x0019 | REQUESTED-TRANSPORT
|0x001A | DONT-FRAGMENT
|0x0021 | Reserved (was TIMER-VAL)
|0x0022 | RESERVATION-TOKEN
|0x8000 | ADDITIONAL-ADDRESS-FAMILY
|0x8001 | ADDRESS-ERROR-CODE
|0x8004 | ICMP
|===

Some of these attributes have lengths that are not multiples of 4. By the rules of STUN, any attribute whose length is not a multiple of 4 bytes [bcp14]#MUST# be immediately followed by 1 to 3 padding bytes to ensure the next attribute (if any) would start on a 4-byte boundary (see <<RFC8489,format=default>>).

[[channelnums]]
[numbered=true,removeInRFC=false,toc=include]
=== CHANNEL-NUMBER

The CHANNEL-NUMBER attribute contains the number of the channel. The value portion of this attribute is 4 bytes long and consists of a 16-bit unsigned integer followed by a two-octet RFFU (Reserved For Future Use) field, which [bcp14]#MUST# be set to 0 on transmission and [bcp14]#MUST# be ignored on reception.

[suppress-title=false,align=left,alt=]
[align=left,alt=,]
....
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Channel Number         |         RFFU = 0              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
....

[numbered=true,removeInRFC=false,toc=include]
=== LIFETIME

The LIFETIME attribute represents the duration for which the server will maintain an allocation in the absence of a refresh. The TURN client can include the LIFETIME attribute with the desired lifetime in Allocate and Refresh requests. The value portion of this attribute is 4 bytes long and consists of a 32-bit unsigned integral value representing the number of seconds remaining until expiration.

[numbered=true,removeInRFC=false,toc=include]
=== XOR-PEER-ADDRESS

The XOR-PEER-ADDRESS attribute specifies the address and port of the peer as seen from the TURN server. (For example, the peer's server-reflexive transport address if the peer is behind a NAT.) It is encoded in the same way as the XOR-MAPPED-ADDRESS attribute <<RFC8489,format=default>>.

[numbered=true,removeInRFC=false,toc=include]
=== DATA

The DATA attribute is present in all Send indications. If the ICMP attribute is not present in a Data indication, it contains a DATA attribute. The value portion of this attribute is variable length and consists of the application data (that is, the data that would immediately follow the UDP header if the data was sent directly between the client and the peer). The application data is equivalent to the "UDP user data" and does not include the "surplus area" defined in <<I-D.ietf-tsvwg-udp-options,format=default: UDP-OPT>>. If the length of this attribute is not a multiple of 4, then padding must be added after this attribute.

[numbered=true,removeInRFC=false,toc=include]
=== XOR-RELAYED-ADDRESS

The XOR-RELAYED-ADDRESS attribute is present in Allocate responses. It specifies the address and port that the server allocated to the client. It is encoded in the same way as the XOR-MAPPED-ADDRESS attribute <<RFC8489,format=default>>.

[[sec-requested-address-family]]
[numbered=true,removeInRFC=false,toc=include]
=== REQUESTED-ADDRESS-FAMILY

This attribute is used in Allocate and Refresh requests to specify the address type requested by the client. The value of this attribute is 4 bytes with the following format:

[suppress-title=false,align=left,alt=]
[align=left,alt=,]
....
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Family    |            Reserved                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
....

[newline=false,spacing=normal]
Family::: There are two values defined for this field and specified in <<RFC8489,format=default>>: 0x01 for IPv4 addresses and 0x02 for IPv6 addresses.
Reserved::: At this point, the 24 bits in the Reserved field [bcp14]#MUST# be set to zero by the client and [bcp14]#MUST# be ignored by the server.

[numbered=true,removeInRFC=false,toc=include]
=== EVEN-PORT

This attribute allows the client to request that the port in the relayed transport address be even and (optionally) that the server reserve the next-higher port number. The value portion of this attribute is 1 byte long. Its format is:

[suppress-title=false,align=left,alt=]
[align=left,alt=,]
....
   0               
   0 1 2 3 4 5 6 7 
  +-+-+-+-+-+-+-+-+
  |R|    RFFU     |
  +-+-+-+-+-+-+-+-+
....

The value contains a single 1-bit flag:

[newline=false,spacing=normal]
R::: If 1, the server is requested to reserve the next-higher port number (on the same IP address) for a subsequent allocation. If 0, no such reservation is requested.
RFFU::: Reserved For Future Use.

The RFFU field must be set to zero on transmission and ignored on reception.

Since the length of this attribute is not a multiple of 4, padding must immediately follow this attribute.

[[sec-requested-transport]]
[numbered=true,removeInRFC=false,toc=include]
=== REQUESTED-TRANSPORT

This attribute is used by the client to request a specific transport protocol for the allocated transport address. The value of this attribute is 4 bytes with the following format:

[suppress-title=false,align=left,alt=]
[align=left,alt=,]
....
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Protocol   |                    RFFU                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
....

The Protocol field specifies the desired protocol. The code points used in this field are taken from those allowed in the Protocol field in the IPv4 header and the NextHeader field in the IPv6 header <<PROTOCOL-NUMBERS,format=default>>. This specification only allows the use of code point 17 (User Datagram Protocol).

The RFFU field [bcp14]#MUST# be set to zero on transmission and [bcp14]#MUST# be ignored on reception. It is reserved for future uses.

[numbered=true,removeInRFC=false,toc=include]
=== DONT-FRAGMENT

This attribute is used by the client to request that the server set the DF (Don't Fragment) bit in the IP header when relaying the application data onward to the peer and for determining the server capability in Allocate requests. This attribute has no value part, and thus, the attribute length field is 0.

[numbered=true,removeInRFC=false,toc=include]
=== RESERVATION-TOKEN

The RESERVATION-TOKEN attribute contains a token that uniquely identifies a relayed transport address being held in reserve by the server. The server includes this attribute in a success response to tell the client about the token, and the client includes this attribute in a subsequent Allocate request to request the server use that relayed transport address for the allocation.

The attribute value is 8 bytes and contains the token value.

[[sec-additional-address-family]]
[numbered=true,removeInRFC=false,toc=include]
=== ADDITIONAL-ADDRESS-FAMILY

This attribute is used by clients to request the allocation of an IPv4 and IPv6 address type from a server. It is encoded in the same way as the REQUESTED-ADDRESS-FAMILY attribute; see <<sec-requested-address-family,format=default>>. The ADDITIONAL-ADDRESS-FAMILY attribute [bcp14]#MAY# be present in the Allocate request. The attribute value of 0x02 (IPv6 address) is the only valid value in Allocate request.

[[sec-address-error-code]]
[numbered=true,removeInRFC=false,toc=include]
=== ADDRESS-ERROR-CODE

This attribute is used by servers to signal the reason for not allocating the requested address family. The value portion of this attribute is variable length with the following format:

[suppress-title=false,align=left,alt=]
[align=left,alt=,]
....
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Family       |    Reserved             |Class|     Number    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      Reason Phrase (variable)                                ..
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
....

[newline=false,spacing=normal]
Family::: There are two values defined for this field and specified in <<RFC8489,format=default>>: 0x01 for IPv4 addresses and 0x02 for IPv6 addresses.
Reserved::: At this point, the 13 bits in the Reserved field [bcp14]#MUST# be set to zero by the server and [bcp14]#MUST# be ignored by the client.
Class::: The Class represents the hundreds digit of the error code and is defined in <<RFC8489,format=default>>.
Number::: This 8-bit field contains the reason the server cannot allocate one of the requested address types. The error code values could be either 440 (Address Family not Supported) or 508 (Insufficient Capacity). The number representation is defined in <<RFC8489,format=default>>.
Reason Phrase::: The recommended reason phrases for error codes 440 and 508 are explained in <<sec-stun-errors,format=default>>. The reason phrase [bcp14]#MUST# be a UTF-8 <<RFC3629,format=default>> encoded sequence of less than 128 characters (which can be as long as 509 bytes when encoding them or 763 bytes when decoding them).

[[icmp]]
[numbered=true,removeInRFC=false,toc=include]
=== ICMP

This attribute is used by servers to signal the reason a UDP packet was dropped. The following is the format of the ICMP attribute.

[suppress-title=false,align=left,alt=]
[align=left,alt=,]
....
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Reserved                     |  ICMP Type  |  ICMP Code      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Error Data                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
....

[newline=false,spacing=normal]
Reserved::: This field [bcp14]#MUST# be set to 0 when sent and [bcp14]#MUST# be ignored when received.
ICMP Type::: The field contains the value of the ICMP type. Its interpretation depends on whether the ICMP was received over IPv4 or IPv6.
ICMP Code::: The field contains the value of the ICMP code. Its interpretation depends on whether the ICMP was received over IPv4 or IPv6.
Error Data::: This field size is 4 bytes long. If the ICMPv6 type is 2 ("Packet too big" message) or ICMPv4 type is 3 (Destination Unreachable) and Code is 4 (fragmentation needed and DF set), the Error Data field will be set to the Maximum Transmission Unit of the next-hop link (<<RFC4443,format=default>> and <<RFC1191,format=default>>). For other ICMPv6 types and ICMPv4 types and codes, the Error Data field [bcp14]#MUST# be set to zero.

[[sec-stun-errors]]
[numbered=true,removeInRFC=false,toc=include]
== STUN Error Response Codes

This document defines the following error response codes:

[newline=true,spacing=normal]
403 (Forbidden)::: The request was valid but cannot be performed due to administrative or similar restrictions.
437 (Allocation Mismatch)::: A request was received by the server that requires an allocation to be in place, but no allocation exists, or a request was received that requires no allocation, but an allocation exists.
440 (Address Family not Supported)::: The server does not support the address family requested by the client.
441 (Wrong Credentials)::: (Wrong Credentials): The credentials in the (non-Allocate) request do not match those used to create the allocation.
442 (Unsupported Transport Protocol)::: The Allocate request asked the server to use a transport protocol between the server and the peer that the server does not support. NOTE: This does NOT refer to the transport protocol used in the 5-tuple.
443 (Peer Address Family Mismatch)::: A peer address is part of a different address family than that of the relayed transport address of the allocation.
486 (Allocation Quota Reached)::: No more allocations using this username can be created at the present time.
508 (Insufficient Capacity)::: The server is unable to carry out the request due to some capacity limit being reached. In an Allocate response, this could be due to the server having no more relayed transport addresses available at that time, having none with the requested properties, or the one that corresponds to the specified reservation token is not available.

[numbered=true,removeInRFC=false,toc=include]
== Detailed Example

This section gives an example of the use of TURN, showing in detail the contents of the messages exchanged. The example uses the network diagram shown in the Overview (<<fig-turn-model,format=default>>).

For each message, the attributes included in the message and their values are shown. For convenience, values are shown in a human-readable format rather than showing the actual octets; for example, "XOR-RELAYED-ADDRESS=192.0.2.15:9000" shows that the XOR-RELAYED-ADDRESS attribute is included with an address of 192.0.2.15 and a port of 9000; here, the address and port are shown before the xor-ing is done. For attributes with string-like values (e.g., SOFTWARE="Example client, version 1.03" and NONCE="obMatJos2gAAAadl7W7PeDU4hKE72jda"), the value of the attribute is shown in quotes for readability, but these quotes do not appear in the actual value.

[suppress-title=false,align=left,alt=]
[align=left,alt=,]
....
TURN                                 TURN          Peer         Peer
client                               server         A            B
  |                                    |            |            |
  |--- Allocate request -------------->|            |            |
  |    Transaction-Id=0xA56250D3F17ABE679422DE85    |            |
  |    SOFTWARE="Example client, version 1.03"      |            |
  |    LIFETIME=3600 (1 hour)          |            |            |
  |    REQUESTED-TRANSPORT=17 (UDP)    |            |            | 
  |    DONT-FRAGMENT                   |            |            |
  |                                    |            |            |
  |<-- Allocate error response --------|            |            |
  |    Transaction-Id=0xA56250D3F17ABE679422DE85    |            |
  |    SOFTWARE="Example server, version 1.17"      |            |
  |    ERROR-CODE=401 (Unauthorized)   |            |            |
  |    REALM="example.com"             |            |            |
  |    NONCE="obMatJos2gAAAadl7W7PeDU4hKE72jda"     |            |
  |    PASSWORD-ALGORITHMS=MD5 and SHA256           |            |
  |                                    |            |            |
  |--- Allocate request -------------->|            |            |
  |    Transaction-Id=0xC271E932AD7446A32C234492    |            |
  |    SOFTWARE="Example client 1.03"  |            |            |
  |    LIFETIME=3600 (1 hour)          |            |            |
  |    REQUESTED-TRANSPORT=17 (UDP)    |            |            |
  |    DONT-FRAGMENT                   |            |            |
  |    USERNAME="George"               |            |            |
  |    REALM="example.com"             |            |            |
  |    NONCE="obMatJos2gAAAadl7W7PeDU4hKE72jda"     |            |
  |    PASSWORD-ALGORITHMS=MD5 and SHA256           |            |
  |    PASSWORD-ALGORITHM=SHA256       |            |            |    
  |    MESSAGE-INTEGRITY=...           |            |            |
  |    MESSAGE-INTEGRITY-SHA256=...    |            |            |
  |                                    |            |            |
  |<-- Allocate success response ------|            |            |
  |    Transaction-Id=0xC271E932AD7446A32C234492    |            |
  |    SOFTWARE="Example server, version 1.17"      |            |
  |    LIFETIME=1200 (20 minutes)      |            |            |
  |    XOR-RELAYED-ADDRESS=192.0.2.15:50000         |            |
  |    XOR-MAPPED-ADDRESS=192.0.2.1:7000            |            |
  |    MESSAGE-INTEGRITY-SHA256=...    |            |            |
....

The client begins by selecting a host transport address to use for the TURN session; in this example, the client has selected 198.51.100.2:49721 as shown in <<fig-turn-model,format=default>>. The client then sends an Allocate request to the server at the server transport address. The client randomly selects a 96-bit transaction id of 0xA56250D3F17ABE679422DE85 for this transaction; this is encoded in the transaction id field in the fixed header. The client includes a SOFTWARE attribute that gives information about the client's software; here, the value is "Example client, version 1.03" to indicate that this is version 1.03 of something called the "Example client". The client includes the LIFETIME attribute because it wishes the allocation to have a longer lifetime than the default of 10 minutes; the value of this attribute is 3600 seconds, which corresponds to 1 hour. The client must always include a REQUESTED-TRANSPORT attribute in an Allocate request, and the only value allowed by this specification is 17, which indicates UDP transport between the server and the peers. The client also includes the DONT-FRAGMENT attribute because it wishes to use the DONT-FRAGMENT attribute later in Send indications; this attribute consists of only an attribute header; there is no value part. We assume the client has not recently interacted with the server; thus, the client does not include the USERNAME, USERHASH, REALM, NONCE, PASSWORD-ALGORITHMS, PASSWORD-ALGORITHM, MESSAGE-INTEGRITY, or MESSAGE-INTEGRITY-SHA256 attribute. Finally, note that the order of attributes in a message is arbitrary (except for the MESSAGE-INTEGRITY, MESSAGE-INTEGRITY-SHA256 and FINGERPRINT attributes), and the client could have used a different order.

Servers require any request to be authenticated. Thus, when the server receives the initial Allocate request, it rejects the request because the request does not contain the authentication attributes. Following the procedures of the long-term credential mechanism of STUN <<RFC8489,format=default>>, the server includes an ERROR-CODE attribute with a value of 401 (Unauthorized), a REALM attribute that specifies the authentication realm used by the server (in this case, the server's domain "example.com"), and a nonce value in a NONCE attribute. The NONCE attribute starts with the "nonce cookie" with the STUN Security Feature "Password algorithm" bit set to 1. The server includes a PASSWORD-ALGORITHMS attribute that specifies the list of algorithms that the server can use to derive the long-term password. If the server sets the STUN Security Feature "Username anonymity" bit to 1, then the client uses the USERHASH attribute instead of the USERNAME attribute in the Allocate request to anonymize the username. The server also includes a SOFTWARE attribute that gives information about the server's software.

The client, upon receipt of the 401 error, reattempts the Allocate request, this time including the authentication attributes. The client selects a new transaction id and then populates the new Allocate request with the same attributes as before. The client includes a USERNAME attribute and uses the realm value received from the server to help it determine which value to use; here, the client is configured to use the username "George" for the realm "example.com". The client includes the PASSWORD-ALGORITHM attribute indicating the algorithm that the server must use to derive the long-term password. The client also includes the REALM, PASSWORD-ALGORITHMS, and NONCE attributes, which are just copied from the 401 error response. Finally, the client includes MESSAGE-INTEGRITY-SHA256 attribute as the last attributes in the message whose value is Hashed Message Authentication Code - Secure Hash Algorithm 2 (HMAC-SHA2) hash over the contents of the message (shown as just "..." above); this HMAC-SHA2 computation includes a password value. Thus, an attacker cannot compute the message integrity value without somehow knowing the secret password.

The server, upon receipt of the authenticated Allocate request, checks that everything is OK, then creates an allocation. The server replies with an Allocate success response. The server includes a LIFETIME attribute giving the lifetime of the allocation; here, the server has reduced the client's requested 1-hour lifetime to just 20 minutes because this particular server doesn't allow lifetimes longer than 20 minutes. The server includes an XOR-RELAYED-ADDRESS attribute whose value is the relayed transport address of the allocation. The server includes an XOR-MAPPED-ADDRESS attribute whose value is the server-reflexive address of the client; this value is not used otherwise in TURN but is returned as a convenience to the client. The server includes a MESSAGE-INTEGRITY-SHA256 attribute to authenticate the response and to ensure its integrity; note that the response does not contain the USERNAME, REALM, and NONCE attributes. The server also includes a SOFTWARE attribute.

[suppress-title=false,align=left,alt=]
[align=left,alt=,]
....
TURN                                 TURN          Peer         Peer
client                               server         A            B
  |--- CreatePermission request ------>|            |            |
  |    Transaction-Id=0xE5913A8F460956CA277D3319    |            |
  |    XOR-PEER-ADDRESS=192.0.2.150:0  |            |            |
  |    USERNAME="George"               |            |            |
  |    REALM="example.com"             |            |            |
  |    NONCE="obMatJos2gAAAadl7W7PeDU4hKE72jda"     |            |
  |    PASSWORD-ALGORITHMS=MD5 and SHA256           |            |
  |    PASSWORD-ALGORITHM=SHA256       |            |            |  
  |    MESSAGE-INTEGRITY-SHA256=...    |            |            |
  |                                    |            |            |
  |<-- CreatePermission success resp.--|            |            |
  |    Transaction-Id=0xE5913A8F460956CA277D3319    |            |
  |    MESSAGE-INTEGRITY-SHA256=...    |            |            |
....

The client then creates a permission towards Peer A in preparation for sending it some application data. This is done through a CreatePermission request. The XOR-PEER-ADDRESS attribute contains the IP address for which a permission is established (the IP address of peer A); note that the port number in the attribute is ignored when used in a CreatePermission request, and here it has been set to 0; also, note how the client uses Peer A's server-reflexive IP address and not its (private) host address. The client uses the same username, realm, and nonce values as in the previous request on the allocation. Though it is allowed to do so, the client has chosen not to include a SOFTWARE attribute in this request.

The server receives the CreatePermission request, creates the corresponding permission, and then replies with a CreatePermission success response. Like the client, the server chooses not to include the SOFTWARE attribute in its reply. Again, note how success responses contain a MESSAGE-INTEGRITY-SHA256 attribute (assuming the server uses the long-term credential mechanism) but no USERNAME, REALM, and NONCE attributes.

[suppress-title=false,align=left,alt=]
[align=left,alt=,]
....
TURN                                 TURN          Peer         Peer
client                               server         A            B
  |--- Send indication --------------->|            |            |
  |    Transaction-Id=0x1278E9ACA2711637EF7D3328    |            |
  |    XOR-PEER-ADDRESS=192.0.2.150:32102           |            |
  |    DONT-FRAGMENT                   |            |            |
  |    DATA=...                        |            |            |
  |                                    |- UDP dgm ->|            |
  |                                    | data=...   |            |
  |                                    |            |            |
  |                                    |<- UDP dgm -|            |
  |                                    |  data=...  |            |
  |<-- Data indication ----------------|            |            |
  |    Transaction-Id=0x8231AE8F9242DA9FF287FEFF    |            |
  |    XOR-PEER-ADDRESS=192.0.2.150:32102           |            |
  |    DATA=...                        |            |            |
....

The client now sends application data to Peer A using a Send indication. Peer A's server-reflexive transport address is specified in the XOR-PEER-ADDRESS attribute, and the application data (shown here as just "...") is specified in the DATA attribute. The client is doing a form of path MTU discovery at the application layer and, thus, specifies (by including the DONT-FRAGMENT attribute) that the server should set the DF bit in the UDP datagram to send to the peer. Indications cannot be authenticated using the long-term credential mechanism of STUN, so no MESSAGE-INTEGRITY or MESSAGE-INTEGRITY-SHA256 attribute is included in the message. An application wishing to ensure that its data is not altered or forged must integrity-protect its data at the application level.

Upon receipt of the Send indication, the server extracts the application data and sends it in a UDP datagram to Peer A, with the relayed transport address as the source transport address of the datagram and with the DF bit set as requested. Note that had the client not previously established a permission for Peer A's server-reflexive IP address, the server would have silently discarded the Send indication instead.

Peer A then replies with its own UDP datagram containing application data. The datagram is sent to the relayed transport address on the server. When this arrives, the server creates a Data indication containing the source of the UDP datagram in the XOR-PEER-ADDRESS attribute, and the data from the UDP datagram in the DATA attribute. The resulting Data indication is then sent to the client.

[suppress-title=false,align=left,alt=]
[align=left,alt=,]
....
TURN                                 TURN          Peer          Peer
client                               server         A             B
  |--- ChannelBind request ----------->|            |             |
  |    Transaction-Id=0x6490D3BC175AFF3D84513212    |             |
  |    CHANNEL-NUMBER=0x4000           |            |             |
  |    XOR-PEER-ADDRESS=192.0.2.210:49191           |             |
  |    USERNAME="George"               |            |             |
  |    REALM="example.com"             |            |             |
  |    NONCE="obMatJos2gAAAadl7W7PeDU4hKE72jda"     |             |
  |    PASSWORD-ALGORITHMS=MD5 and SHA256           |             |
  |    PASSWORD-ALGORITHM=SHA256       |            |             |  
  |    MESSAGE-INTEGRITY-SHA256=...    |            |             |
  |                                    |            |             |
  |<-- ChannelBind success response ---|            |             |
  |    Transaction-Id=0x6490D3BC175AFF3D84513212    |             |
  |    MESSAGE-INTEGRITY-SHA256=...    |            |             |
....

The client now binds a channel to Peer B, specifying a free channel number (0x4000) in the CHANNEL-NUMBER attribute, and Peer B's transport address in the XOR-PEER-ADDRESS attribute. As before, the client reuses the username, realm, and nonce from its last request in the message.

Upon receipt of the request, the server binds the channel number to the peer, installs a permission for Peer B's IP address, and then replies with a ChannelBind success response.

[suppress-title=false,align=left,alt=]
[align=left,alt=,]
....
TURN                                TURN           Peer          Peer
client                              server          A             B
  |--- ChannelData ------------------>|             |             |
  |    Channel-number=0x4000          |--- UDP datagram --------->|
  |    Data=...                       |    Data=...               |
  |                                   |             |             |
  |                                   |<-- UDP datagram ----------|
  |                                   |    Data=... |             |
  |<-- ChannelData -------------------|             |             |
  |    Channel-number=0x4000          |             |             |
  |    Data=...                       |             |             |
....

The client now sends a ChannelData message to the server with data destined for Peer B. The ChannelData message is not a STUN message; thus, it has no transaction id. Instead, it has only three fields: a channel number, data, and data length; here, the channel number field is 0x4000 (the channel the client just bound to Peer B). When the server receives the ChannelData message, it checks that the channel is currently bound (which it is) and then sends the data onward to Peer B in a UDP datagram, using the relayed transport address as the source transport address, and 192.0.2.210:49191 (the value of the XOR-PEER-ADDRESS attribute in the ChannelBind request) as the destination transport address.

Later, Peer B sends a UDP datagram back to the relayed transport address. This causes the server to send a ChannelData message to the client containing the data from the UDP datagram. The server knows to which client to send the ChannelData message because of the relayed transport address at which the UDP datagram arrived, and it knows to use channel 0x4000 because this is the channel bound to 192.0.2.210:49191. Note that if there had not been any channel number bound to that address, the server would have used a Data indication instead.

[suppress-title=false,align=left,alt=]
[align=left,alt=,]
....
TURN                                 TURN          Peer         Peer
client                               server         A            B
  |--- ChannelBind request ----------->|            |            |
  |    Transaction-Id=0xE5913A8F46091637EF7D3328    |            |
  |    CHANNEL-NUMBER=0x4000           |            |            |
  |    XOR-PEER-ADDRESS=192.0.2.210:49191           |            |
  |    USERNAME="George"               |            |            |
  |    REALM="example.com"             |            |            |
  |    NONCE="obMatJos2gAAAadl7W7PeDU4hKE72jda"     |            |
  |    PASSWORD-ALGORITHMS=MD5 and SHA256           |            |
  |    PASSWORD-ALGORITHM=SHA256       |            |            |  
  |    MESSAGE-INTEGRITY-SHA256=...    |            |            |
  |                                    |            |            |
  |<-- ChannelBind success response ---|            |            |
  |    Transaction-Id=0xE5913A8F46091637EF7D3328    |            |
  |    MESSAGE-INTEGRITY-SHA256=...    |            |            |
....

The channel binding lasts for 10 minutes unless refreshed. The TURN client refreshes the binding by sending a ChannelBind request rebinding the channel to the same peer (Peer B's IP address). The server processes the ChannelBind request, rebinds the channel to the same peer, and resets the time-to-expiry timer back to 10 minutes.

[suppress-title=false,align=left,alt=]
[align=left,alt=,]
....
TURN                                 TURN          Peer         Peer
client                               server         A            B
  |--- Refresh request --------------->|            |            |
  |    Transaction-Id=0x0864B3C27ADE9354B4312414    |            |
  |    SOFTWARE="Example client 1.03"  |            |            |
  |    USERNAME="George"               |            |            |
  |    REALM="example.com"             |            |            |
  |    NONCE="oobMatJos2gAAAadl7W7PeDU4hKE72jda"    |            |
  |    PASSWORD-ALGORITHMS=MD5 and SHA256           |            |
  |    PASSWORD-ALGORITHM=SHA256       |            |            |  
  |    MESSAGE-INTEGRITY-SHA256=...    |            |            |
  |                                    |            |            |
  |<-- Refresh error response ---------|            |            |
  |    Transaction-Id=0x0864B3C27ADE9354B4312414    |            |
  |    SOFTWARE="Example server, version 1.17"      |            |
  |    ERROR-CODE=438 (Stale Nonce)    |            |            |
  |    REALM="example.com"             |            |            |
  |    NONCE="obMatJos2gAAAadl7W7PeDU4hKE72jda"     |            |
  |    PASSWORD-ALGORITHMS=MD5 and SHA256           |            |
  |                                    |            |            |
  |--- Refresh request --------------->|            |            |
  |    Transaction-Id=0x427BD3E625A85FC731DC4191    |            |
  |    SOFTWARE="Example client 1.03"  |            |            |
  |    USERNAME="George"               |            |            |
  |    REALM="example.com"             |            |            |
  |    NONCE="obMatJos2gAAAadl7W7PeDU4hKE72jda"     |            |
  |    PASSWORD-ALGORITHMS=MD5 and SHA256           |            |
  |    PASSWORD-ALGORITHM=SHA256       |            |            | 
  |    MESSAGE-INTEGRITY-SHA256=...    |            |            |
  |                                    |            |            |
  |<-- Refresh success response -------|            |            |
  |    Transaction-Id=0x427BD3E625A85FC731DC4191    |            |
  |    SOFTWARE="Example server, version 1.17"      |            |
  |    LIFETIME=600 (10 minutes)       |            |            |
  |    MESSAGE-INTEGRITY=...           |            |            |
....

Sometime before the 20-minute lifetime is up, the client refreshes the allocation. This is done using a Refresh request. As before, the client includes the latest username, realm, and nonce values in the request. The client also includes the SOFTWARE attribute, following the recommended practice of always including this attribute in Allocate and Refresh messages. When the server receives the Refresh request, it notices that the nonce value has expired and so replies with a 438 (Stale Nonce) error given a new nonce value. The client then reattempts the request, this time with the new nonce value. This second attempt is accepted, and the server replies with a success response. Note that the client did not include a LIFETIME attribute in the request, so the server refreshes the allocation for the default lifetime of 10 minutes (as can be seen by the LIFETIME attribute in the success response).

[[sec-security]]
[numbered=true,removeInRFC=false,toc=include]
== Security Considerations

This section considers attacks that are possible in a TURN deployment and discusses how they are mitigated by mechanisms in the protocol or recommended practices in the implementation.

Most of the attacks on TURN are mitigated by the server requiring requests be authenticated. Thus, this specification requires the use of authentication. The mandatory-to-implement mechanism is the long- term credential mechanism of STUN. Other authentication mechanisms of equal or stronger security properties may be used. However, it is important to ensure that they can be invoked in an interoperable way.

[numbered=true,removeInRFC=false,toc=include]
=== Outsider Attacks

Outsider attacks are ones where the attacker has no credentials in the system and is attempting to disrupt the service seen by the client or the server.

[numbered=true,removeInRFC=false,toc=include]
==== Obtaining Unauthorized Allocations

An attacker might wish to obtain allocations on a TURN server for any number of nefarious purposes. A TURN server provides a mechanism for sending and receiving packets while cloaking the actual IP address of the client. This makes TURN servers an attractive target for attackers who wish to use it to mask their true identity.

An attacker might also wish to simply utilize the services of a TURN server without paying for them. Since TURN services require resources from the provider, it is anticipated that their usage will come with a cost.

These attacks are prevented using the long-term credential mechanism, which allows the TURN server to determine the identity of the requestor and whether the requestor is allowed to obtain the allocation.

[numbered=true,removeInRFC=false,toc=include]
==== Offline Dictionary Attacks

The long-term credential mechanism used by TURN is subject to offline dictionary attacks. An attacker that is capable of eavesdropping on a message exchange between a client and server can determine the password by trying a number of candidate passwords and seeing if one of them is correct. This attack works when the passwords are low entropy such as a word from the dictionary. This attack can be mitigated by using strong passwords with large entropy. In situations where even stronger mitigation is required, (D)TLS transport between the client and the server can be used.

[numbered=true,removeInRFC=false,toc=include]
==== Faked Refreshes and Permissions

An attacker might wish to attack an active allocation by sending it a Refresh request with an immediate expiration in order to delete it and disrupt service to the client. This is prevented by authentication of refreshes. Similarly, an attacker wishing to send CreatePermission requests to create permissions to undesirable destinations is prevented from doing so through authentication. The motivations for such an attack are described in <<sec-firewall,format=default>>.

[[fate-data]]
[numbered=true,removeInRFC=false,toc=include]
==== Fake Data

An attacker might wish to send data to the client or the peer as if they came from the peer or client, respectively. To do that, the attacker can send the client a faked Data indication or ChannelData message, or send the TURN server a faked Send indication or ChannelData message.

Since indications and ChannelData messages are not authenticated, this attack is not prevented by TURN. However, this attack is generally present in IP-based communications and is not substantially worsened by TURN. Consider a normal, non-TURN IP session between hosts A and B. An attacker can send packets to B as if they came from A by sending packets towards B with a spoofed IP address of A. This attack requires the attacker to know the IP addresses of A and B. With TURN, an attacker wishing to send packets towards a client using a Data indication needs to know its IP address (and port), the IP address and port of the TURN server, and the IP address and port of the peer (for inclusion in the XOR-PEER-ADDRESS attribute). To send a fake ChannelData message to a client, an attacker needs to know the IP address and port of the client, the IP address and port of the TURN server, and the channel number. This particular combination is mildly more guessable than in the non-TURN case.

These attacks are more properly mitigated by application-layer authentication techniques. In the case of real-time traffic, usage of SRTP <<RFC3711,format=default>> prevents these attacks.

In some situations, the TURN server may be situated in the network such that it is able to send to hosts to which the client cannot directly send. This can happen, for example, if the server is located behind a firewall that allows packets from outside the firewall to be delivered to the server, but not to other hosts behind the firewall. In these situations, an attacker could send the server a Send indication with an XOR-PEER-ADDRESS attribute containing the transport address of one of the other hosts behind the firewall. If the server was to allow relaying of traffic to arbitrary peers, then this would provide a way for the attacker to attack arbitrary hosts behind the firewall.

To mitigate this attack, TURN requires that the client establish a permission to a host before sending it data. Thus, an attacker can only attack hosts with which the client is already communicating unless the attacker is able to create authenticated requests. Furthermore, the server administrator may configure the server to restrict the range of IP addresses and ports to which it will relay data. To provide even greater security, the server administrator can require that the client use (D)TLS for all communication between the client and the server.

[numbered=true,removeInRFC=false,toc=include]
==== Impersonating a Server

When a client learns a relayed address from a TURN server, it uses that relayed address in application protocols to receive traffic. Therefore, an attacker wishing to intercept or redirect that traffic might try to impersonate a TURN server and provide the client with a faked relayed address.

This attack is prevented through the long-term credential mechanism, which provides message integrity for responses in addition to verifying that they came from the server. Furthermore, an attacker cannot replay old server responses as the transaction id in the STUN header prevents this. Replay attacks are further thwarted through frequent changes to the nonce value.

[numbered=true,removeInRFC=false,toc=include]
==== Eavesdropping Traffic

If the TURN client and server use the STUN Extension for Third-Party Authorization <<RFC7635,format=default>> (for example, it is used in WebRTC), the username does not reveal the real user's identity; the USERNAME attribute carries an ephemeral and unique key identifier. If the TURN client and server use the STUN long-term credential mechanism and the username reveals the real user's identity, the client [bcp14]#MUST# either use the USERHASH attribute instead of the USERNAME attribute to anonymize the username or use (D)TLS transport between the client and the server.

If the TURN client and server use the STUN long-term credential mechanism, and realm information is privacy sensitive, TURN can be run over (D)TLS. As a reminder, STUN Extension for Third-Party Authorization does not use realm.

The SOFTWARE attribute can reveal the specific software version of the TURN client and server to the eavesdropper, and it might possibly allow attacks against vulnerable software that is known to contain security vulnerabilities. If the software version is known to contain security vulnerabilities, TURN [bcp14]#SHOULD# be run over (D)TLS to prevent leaking the SOFTWARE attribute in clear text. If zero-day vulnerabilities are detected in the software version, the endpoint policy can be modified to mandate the use of (D)TLS until the patch is in place to fix the flaw.

TURN concerns itself primarily with authentication and message integrity. Confidentiality is only a secondary concern as TURN control messages do not include information that is particularly sensitive with the exception of USERNAME, REALM, and SOFTWARE. The primary protocol content of the messages is the IP address of the peer. If it is important to prevent an eavesdropper on a TURN connection from learning this, TURN can be run over (D)TLS.

Confidentiality for the application data relayed by TURN is best provided by the application protocol itself since running TURN over (D)TLS does not protect application data between the server and the peer. If confidentiality of application data is important, then the application should encrypt or otherwise protect its data. For example, for real-time media, confidentiality can be provided by using SRTP.

[numbered=true,removeInRFC=false,toc=include]
==== TURN Loop Attack

An attacker might attempt to cause data packets to loop indefinitely between two TURN servers. The attack goes as follows: first, the attacker sends an Allocate request to server A using the source address of server B. Server A will send its response to server B, and for the attack to succeed, the attacker must have the ability to either view or guess the contents of this response so that the attacker can learn the allocated relayed transport address. The attacker then sends an Allocate request to server B using the source address of server A. Again, the attacker must be able to view or guess the contents of the response so it can learn the allocated relayed transport address. Using the same spoofed source address technique, the attacker then binds a channel number on server A to the relayed transport address on server B and similarly binds the same channel number on server B to the relayed transport address on server A. Finally, the attacker sends a ChannelData message to server A.

The result is a data packet that loops from the relayed transport address on server A to the relayed transport address on server B, then from server B's transport address to server A's transport address, and then around the loop again.

This attack is mitigated as follows: by requiring all requests to be authenticated and/or by randomizing the port number allocated for the relayed transport address, the server forces the attacker to either intercept or view responses sent to a third party (in this case, the other server) so that the attacker can authenticate the requests and learn the relayed transport address. Without one of these two measures, an attacker can guess the contents of the responses without needing to see them, which makes the attack much easier to perform. Furthermore, by requiring authenticated requests, the server forces the attacker to have credentials acceptable to the server, which turns this from an outsider attack into an insider attack and allows the attack to be traced back to the client initiating it.

The attack can be further mitigated by imposing a per-username limit on the bandwidth used to relay data by allocations owned by that username to limit the impact of this attack on other allocations. More mitigation can be achieved by decrementing the TTL when relaying data packets (if the underlying OS allows this).

[[sec-firewall]]
[numbered=true,removeInRFC=false,toc=include]
=== Firewall Considerations

A key security consideration of TURN is that TURN should not weaken the protections afforded by firewalls deployed between a client and a TURN server. It is anticipated that TURN servers will often be present on the public Internet, and clients may often be inside enterprise networks with corporate firewalls. If TURN servers provide a "backdoor" for reaching into the enterprise, TURN will be blocked by these firewalls.

TURN servers therefore emulate the behavior of NAT devices that implement address-dependent filtering <<RFC4787,format=default>>, a property common in many firewalls as well. When a NAT or firewall implements this behavior, packets from an outside IP address are only allowed to be sent to an internal IP address and port if the internal IP address and port had recently sent a packet to that outside IP address. TURN servers introduce the concept of permissions, which provide exactly this same behavior on the TURN server. An attacker cannot send a packet to a TURN server and expect it to be relayed towards the client, unless the client has tried to contact the attacker first.

It is important to note that some firewalls have policies that are even more restrictive than address-dependent filtering. Firewalls can also be configured with address- and port-dependent filtering, or they can be configured to disallow inbound traffic entirely. In these cases, if a client is allowed to connect the TURN server, communications to the client will be less restrictive than what the firewall would normally allow.

[numbered=true,removeInRFC=false,toc=include]
==== Faked Permissions

In firewalls and NAT devices, permissions are granted implicitly through the traversal of a packet from the inside of the network towards the outside peer. Thus, a permission cannot, by definition, be created by any entity except one inside the firewall or NAT. With TURN, this restriction no longer holds. Since the TURN server sits outside the firewall, an attacker outside the firewall can now send a message to the TURN server and try to create a permission for itself.

This attack is prevented because all messages that create permissions (i.e., ChannelBind and CreatePermission) are authenticated.

[numbered=true,removeInRFC=false,toc=include]
==== Blacklisted IP Addresses

Many firewalls can be configured with blacklists that prevent a client behind the firewall from sending packets to, or receiving packets from, ranges of blacklisted IP addresses. This is accomplished by inspecting the source and destination addresses of packets entering and exiting the firewall, respectively.

This feature is also present in TURN since TURN servers are allowed to arbitrarily restrict the range of addresses of peers that they will relay to.

[numbered=true,removeInRFC=false,toc=include]
==== Running Servers on Well-Known Ports

A malicious client behind a firewall might try to connect to a TURN server and obtain an allocation that it then uses to run a server. For example, a client might try to run a DNS server or FTP server.

This is not possible in TURN. A TURN server will never accept traffic from a peer for which the client has not installed a permission. Thus, peers cannot just connect to the allocated port in order to obtain the service.

[numbered=true,removeInRFC=false,toc=include]
=== Insider Attacks

In insider attacks, a client has legitimate credentials but defies the trust relationship that goes with those credentials. These attacks cannot be prevented by cryptographic means but need to be considered in the design of the protocol.

[numbered=true,removeInRFC=false,toc=include]
==== DoS against TURN Server

A client wishing to disrupt service to other clients might obtain an allocation and then flood it with traffic in an attempt to swamp the server and prevent it from servicing other legitimate clients. This is mitigated by the recommendation that the server limit the amount of bandwidth it will relay for a given username. This won't prevent a client from sending a large amount of traffic, but it allows the server to immediately discard traffic in excess.

Since each allocation uses a port number on the IP address of the TURN server, the number of allocations on a server is finite. An attacker might attempt to consume all of them by requesting a large number of allocations. This is prevented by the recommendation that the server impose a limit on the number of allocations active at a time for a given username.

[numbered=true,removeInRFC=false,toc=include]
==== Anonymous Relaying of Malicious Traffic

TURN servers provide a degree of anonymization. A client can send data to peers without revealing its own IP address. TURN servers may therefore become attractive vehicles for attackers to launch attacks against targets without fear of detection. Indeed, it is possible for a client to chain together multiple TURN servers such that any number of relays can be used before a target receives a packet.

Administrators who are worried about this attack can maintain logs that capture the actual source IP and port of the client and perhaps even every permission that client installs. This will allow for forensic tracing to determine the original source should it be discovered that an attack is being relayed through a TURN server.

[numbered=true,removeInRFC=false,toc=include]
==== Manipulating Other Allocations

An attacker might attempt to disrupt service to other users of the TURN server by sending Refresh requests or CreatePermission requests that (through source address spoofing) appear to be coming from another user of the TURN server. TURN prevents this by requiring that the credentials used in CreatePermission, Refresh, and ChannelBind messages match those used to create the initial allocation. Thus, the fake requests from the attacker will be rejected.

[numbered=true,removeInRFC=false,toc=include]
=== Tunnel Amplification Attack

An attacker might attempt to cause data packets to loop numerous times between a TURN server and a tunnel between IPv4 and IPv6. The attack goes as follows:

Suppose an attacker knows that a tunnel endpoint will forward encapsulated packets from a given IPv6 address (this doesn't necessarily need to be the tunnel endpoint's address). Suppose he then spoofs two packets from this address:

[spacing=normal,start=1,format=arabic]
. An Allocate request asking for a v4 address, and
. A ChannelBind request establishing a channel to the IPv4 address of the tunnel endpoint.

Then, he has set up an amplification attack:

[nobullet=false,spacing=normal]
* The TURN server will re-encapsulate IPv6 UDP data in v4 and send it to the tunnel endpoint.
* The tunnel endpoint will de-encapsulate packets from the v4 interface and send them to v6.

So, if the attacker sends a packet of the following form:

[suppress-title=false,align=left,alt=]
[align=left,alt=,]
....
  IPv6: src=2001:DB8:1::1 dst=2001:DB8::2
  UDP:  <ports>
  TURN: <channel id>
  IPv6: src=2001:DB8:1::1 dst=2001:DB8::2
  UDP:  <ports>
  TURN: <channel id>
  IPv6: src=2001:DB8:1::1 dst=2001:DB8::2
  UDP:  <ports>
  TURN: <channel id>
  ...      
....

then the TURN server and the tunnel endpoint will send it back and forth until the last TURN header is consumed, at which point the TURN server will send an empty packet that the tunnel endpoint will drop.

The amplification potential here is limited by the MTU, so it's not huge: IPv6+UDP+TURN takes 334 bytes, so a four-to-one amplification out of a 1500-byte packet is possible. But, the attacker could still increase traffic volume by sending multiple packets or by establishing multiple channels spoofed from different addresses behind the same tunnel endpoint.

The attack is mitigated as follows. It is [bcp14]#RECOMMENDED# that TURN servers not accept allocation or channel-binding requests from addresses known to be tunneled, and that they not forward data to such addresses. In particular, a TURN server [bcp14]#MUST NOT# accept Teredo or 6to4 addresses in these requests.

[numbered=true,removeInRFC=false,toc=include]
=== Other Considerations

Any relay addresses learned through an Allocate request will not operate properly with IPsec Authentication Header (AH) <<RFC4302,format=default>> in transport or tunnel mode. However, tunnel-mode IPsec Encapsulating Security Payload (ESP) <<RFC4303,format=default>> should still operate.

[numbered=true,removeInRFC=false,toc=include]
== IANA Considerations

The code points for the STUN methods defined in this specification are listed in <<sec-stun-methods,format=default>>. IANA has updated the references from <<RFC5766,format=default>> to this document (for the STUN methods listed in <<sec-stun-methods,format=default>>).

The code points for the STUN attributes defined in this specification are listed in <<sec-stun-attributes,format=default>>. IANA has updated the references from <<RFC5766,format=default>> to this document (for the STUN attributes CHANNEL-NUMBER, LIFETIME, Reserved (was BANDWIDTH), XOR-PEER-ADDRESS, DATA, XOR-RELAYED-ADDRESS, REQUESTED-ADDRESS-FAMILY, EVEN-PORT, REQUESTED-TRANSPORT, DONT-FRAGMENT, Reserved (was TIMER-VAL), and RESERVATION-TOKEN listed in <<sec-stun-attributes,format=default>>).

The code points for the STUN error codes defined in this specification are listed in <<sec-stun-errors,format=default>>. IANA has updated the references from <<RFC5766,format=default>> and <<RFC6156,format=default>> to this document (for the STUN error codes listed in <<sec-stun-errors,format=default>>).

IANA has updated the references to <<RFC5766,format=default>> to this document for the SRV service name of "turn" for TURN over UDP or TCP and the service name of "turns" for TURN over (D)TLS.

IANA has created a registry for TURN channel numbers (the "Traversal Using Relays around NAT (TURN) Channel Numbers" registry), initially populated as follows:

[[turn-channel-numbers]]
[align=center]
|===
|0x0000 through 0x3FFF: | Reserved and not available for use since they conflict with the STUN header.
|0x4000 through 0x4FFF: | A TURN implementation is free to use channel numbers in this range.
|0x5000 through 0xFFFF: | Reserved (For DTLS-SRTP multiplexing collision avoidance, see <<RFC7983,format=default>>)
|===

Any change to this registry must be made through an IETF Standards Action.

[numbered=true,removeInRFC=false,toc=include]
== IAB Considerations

The IAB has studied the problem of Unilateral Self-Address Fixing (UNSAF), which is the general process by which a client attempts to determine its address in another realm on the other side of a NAT through a collaborative protocol reflection mechanism <<RFC3424,format=default>>. The TURN extension is an example of a protocol that performs this type of function. The IAB has mandated that any protocols developed for this purpose document a specific set of considerations. These considerations and the responses for TURN are documented in this section.

Consideration 1: Precise definition of a specific, limited-scope problem that is to be solved with the UNSAF proposal. A short-term fix should not be generalized to solve other problems. Such generalizations lead to the prolonged dependence on and usage of the supposed short-term fix, meaning that it is no longer accurate to call it "short-term".

Response: TURN is a protocol for communication between a relay (= TURN server) and its client. The protocol allows a client that is behind a NAT to obtain and use a public IP address on the relay. As a convenience to the client, TURN also allows the client to determine its server-reflexive transport address.

Consideration 2: Description of an exit strategy/transition plan. The better short-term fixes are the ones that will naturally see less and less use as the appropriate technology is deployed.

Response: TURN will no longer be needed once there are no longer any NATs. Unfortunately, as of the date of publication of this document, it no longer seems very likely that NATs will go away any time soon. However, the need for TURN will also decrease as the number of NATs with the mapping property of Endpoint-Independent Mapping <<RFC4787,format=default>> increases.

Consideration 3: Discussion of specific issues that may render systems more "brittle". For example, approaches that involve using data at multiple network layers create more dependencies, increase debugging challenges, and make it harder to transition.

Response: TURN is "brittle" in that it requires the NAT bindings between the client and the server to be maintained unchanged for the lifetime of the allocation. This is typically done using keep-alives. If this is not done, then the client will lose its allocation and can no longer exchange data with its peers.

Consideration 4: Identify requirements for longer-term, sound technical solutions; contribute to the process of finding the right longer-term solution.

Response: The need for TURN will be reduced once NATs implement the recommendations for NAT UDP behavior documented in <<RFC4787,format=default>>. Applications are also strongly urged to use ICE <<RFC8445,format=default>> to communicate with peers; though ICE uses TURN, it does so only as a last resort, and it uses it in a controlled manner.

Consideration 5: Discussion of the impact of the noted practical issues with existing deployed NATs and experience reports.

Response: Some NATs deployed today exhibit a mapping behavior other than Endpoint-Independent mapping. These NATs are difficult to work with, as they make it difficult or impossible for protocols like ICE to use server-reflexive transport addresses on those NATs. A client behind such a NAT is often forced to use a relay protocol like TURN because "UDP hole punching" techniques <<RFC5128,format=default>> do not work.

[numbered=true,removeInRFC=false,toc=include]
== Changes since RFC 5766

This section lists the major changes in the TURN protocol from the original <<RFC5766,format=default>> specification.

[nobullet=false,spacing=normal]
* IPv6 support.
* REQUESTED-ADDRESS-FAMILY attribute.
* Description of the tunnel amplification attack.
* DTLS support.
* Add support for receiving ICMP packets.
* Updates PMTUD.
* Discovery of TURN server.
* TURN URI Scheme Semantics.
* Happy Eyeballs for TURN.
* Align with the changes in STUN<<RFC8489,format=default>>.

[numbered=true,removeInRFC=false,toc=include]
== Updates to RFC 6156

This section lists the major updates to <<RFC6156,format=default>> in this specification.

[nobullet=false,spacing=normal]
* ADDITIONAL-ADDRESS-FAMILY and ADDRESS-ERROR-CODE attributes.
* 440 (Address Family not Supported) and 443 (Peer Address Family Mismatch) responses.
* More details on packet translation.
* TCP-to-UDP and UDP-to-TCP relaying.

[bibliography]
== Normative References
++++
<reference anchor="PROTOCOL-NUMBERS" derivedAnchor="PROTOCOL-NUMBERS" quoteTitle="true" target="https://www.iana.org/assignments/protocol-numbers"><front><title>Protocol Numbers</title>
<author><organization showOnFrontPage="true">IANA</organization>
</author>
<date></date>
</front>
</reference>
<reference anchor="RFC0792" derivedAnchor="RFC0792" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc792"><front><title>Internet Control Message Protocol</title>
<author fullname="J. Postel" initials="J." surname="Postel"><organization showOnFrontPage="true"></organization>
</author>
<date month="September" year="1981"></date>
</front>
<seriesInfo name="STD" value="5"></seriesInfo>
<seriesInfo name="RFC" value="792"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC0792"></seriesInfo>
</reference>
<reference anchor="RFC1122" derivedAnchor="RFC1122" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc1122"><front><title>Requirements for Internet Hosts - Communication Layers</title>
<author fullname="R. Braden" initials="R." role="editor" surname="Braden"><organization showOnFrontPage="true"></organization>
</author>
<date month="October" year="1989"></date>
<abstract><t>This RFC is an official specification for the Internet community.  It incorporates by reference, amends, corrects, and supplements the primary protocol standards documents relating to hosts.  [STANDARDS-TRACK]</t>
</abstract>
</front>
<seriesInfo name="STD" value="3"></seriesInfo>
<seriesInfo name="RFC" value="1122"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC1122"></seriesInfo>
</reference>
<reference anchor="RFC2119" derivedAnchor="RFC2119" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc2119"><front><title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author fullname="S. Bradner" initials="S." surname="Bradner"><organization showOnFrontPage="true"></organization>
</author>
<date month="March" year="1997"></date>
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
</abstract>
</front>
<seriesInfo name="BCP" value="14"></seriesInfo>
<seriesInfo name="RFC" value="2119"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC2119"></seriesInfo>
</reference>
<reference anchor="RFC2474" derivedAnchor="RFC2474" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc2474"><front><title>Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers</title>
<author fullname="K. Nichols" initials="K." surname="Nichols"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="S. Blake" initials="S." surname="Blake"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="F. Baker" initials="F." surname="Baker"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="D. Black" initials="D." surname="Black"><organization showOnFrontPage="true"></organization>
</author>
<date month="December" year="1998"></date>
<abstract><t>This document defines the IP header field, called the DS (for differentiated services) field.  [STANDARDS-TRACK]</t>
</abstract>
</front>
<seriesInfo name="RFC" value="2474"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC2474"></seriesInfo>
</reference>
<reference anchor="RFC3168" derivedAnchor="RFC3168" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc3168"><front><title>The Addition of Explicit Congestion Notification (ECN) to IP</title>
<author fullname="K. Ramakrishnan" initials="K." surname="Ramakrishnan"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="S. Floyd" initials="S." surname="Floyd"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="D. Black" initials="D." surname="Black"><organization showOnFrontPage="true"></organization>
</author>
<date month="September" year="2001"></date>
<abstract><t>This memo specifies the incorporation of ECN (Explicit Congestion Notification) to TCP and IP, including ECN's use of two bits in the IP header.  [STANDARDS-TRACK]</t>
</abstract>
</front>
<seriesInfo name="RFC" value="3168"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC3168"></seriesInfo>
</reference>
<reference anchor="RFC3629" derivedAnchor="RFC3629" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc3629"><front><title>UTF-8, a transformation format of ISO 10646</title>
<author fullname="F. Yergeau" initials="F." surname="Yergeau"><organization showOnFrontPage="true"></organization>
</author>
<date month="November" year="2003"></date>
<abstract><t>ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems.  The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo.  UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values.  This memo obsoletes and replaces RFC 2279.</t>
</abstract>
</front>
<seriesInfo name="STD" value="63"></seriesInfo>
<seriesInfo name="RFC" value="3629"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC3629"></seriesInfo>
</reference>
<reference anchor="RFC4443" derivedAnchor="RFC4443" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc4443"><front><title>Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification</title>
<author fullname="A. Conta" initials="A." surname="Conta"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="S. Deering" initials="S." surname="Deering"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="M. Gupta" initials="M." role="editor" surname="Gupta"><organization showOnFrontPage="true"></organization>
</author>
<date month="March" year="2006"></date>
<abstract><t>This document describes the format of a set of control messages used in ICMPv6 (Internet Control Message Protocol).  ICMPv6 is the Internet Control Message Protocol for Internet Protocol version 6 (IPv6).  [STANDARDS-TRACK]</t>
</abstract>
</front>
<seriesInfo name="STD" value="89"></seriesInfo>
<seriesInfo name="RFC" value="4443"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC4443"></seriesInfo>
</reference>
<reference anchor="RFC6347" derivedAnchor="RFC6347" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc6347"><front><title>Datagram Transport Layer Security Version 1.2</title>
<author fullname="E. Rescorla" initials="E." surname="Rescorla"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="N. Modadugu" initials="N." surname="Modadugu"><organization showOnFrontPage="true"></organization>
</author>
<date month="January" year="2012"></date>
<abstract><t>This document specifies version 1.2 of the Datagram Transport Layer Security (DTLS) protocol.  The DTLS protocol provides communications privacy for datagram protocols.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  The DTLS protocol is based on the Transport Layer Security (TLS) protocol and provides equivalent security guarantees.  Datagram semantics of the underlying transport are preserved by the DTLS protocol.  This document updates DTLS 1.0 to work with TLS version 1.2.  [STANDARDS-TRACK]</t>
</abstract>
</front>
<seriesInfo name="RFC" value="6347"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC6347"></seriesInfo>
</reference>
<reference anchor="RFC6437" derivedAnchor="RFC6437" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc6437"><front><title>IPv6 Flow Label Specification</title>
<author fullname="S. Amante" initials="S." surname="Amante"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="B. Carpenter" initials="B." surname="Carpenter"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="S. Jiang" initials="S." surname="Jiang"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="J. Rajahalme" initials="J." surname="Rajahalme"><organization showOnFrontPage="true"></organization>
</author>
<date month="November" year="2011"></date>
<abstract><t>This document specifies the IPv6 Flow Label field and the minimum requirements for IPv6 nodes labeling flows, IPv6 nodes forwarding labeled packets, and flow state establishment methods.  Even when mentioned as examples of possible uses of the flow labeling, more detailed requirements for specific use cases are out of the scope for this document.</t>
<t>The usage of the Flow Label field enables efficient IPv6 flow classification based only on IPv6 main header fields in fixed positions.  [STANDARDS-TRACK]</t>
</abstract>
</front>
<seriesInfo name="RFC" value="6437"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC6437"></seriesInfo>
</reference>
<reference anchor="RFC7065" derivedAnchor="RFC7065" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc7065"><front><title>Traversal Using Relays around NAT (TURN) Uniform Resource Identifiers</title>
<author fullname="M. Petit-Huguenin" initials="M." surname="Petit-Huguenin"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="S. Nandakumar" initials="S." surname="Nandakumar"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="G. Salgueiro" initials="G." surname="Salgueiro"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="P. Jones" initials="P." surname="Jones"><organization showOnFrontPage="true"></organization>
</author>
<date month="November" year="2013"></date>
<abstract><t>This document specifies the syntax of Uniform Resource Identifier (URI) schemes for the Traversal Using Relays around NAT (TURN) protocol.  It defines two URI schemes to provision the TURN Resolution Mechanism (RFC 5928).</t>
</abstract>
</front>
<seriesInfo name="RFC" value="7065"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC7065"></seriesInfo>
</reference>
<reference anchor="RFC7350" derivedAnchor="RFC7350" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc7350"><front><title>Datagram Transport Layer Security (DTLS) as Transport for Session Traversal Utilities for NAT (STUN)</title>
<author fullname="M. Petit-Huguenin" initials="M." surname="Petit-Huguenin"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="G. Salgueiro" initials="G." surname="Salgueiro"><organization showOnFrontPage="true"></organization>
</author>
<date month="August" year="2014"></date>
<abstract><t>This document specifies the usage of Datagram Transport Layer Security (DTLS) as a transport protocol for Session Traversal Utilities for NAT (STUN).  It provides guidance on when and how to use DTLS with the currently standardized STUN usages.  It also specifies modifications to the STUN and Traversal Using Relay NAT (TURN) URIs and to the TURN resolution mechanism to facilitate the resolution of STUN and TURN URIs into the IP address and port of STUN and TURN servers supporting DTLS as a transport protocol.  This document updates RFCs 5389 and 5928.</t>
</abstract>
</front>
<seriesInfo name="RFC" value="7350"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC7350"></seriesInfo>
</reference>
<reference anchor="RFC7525" derivedAnchor="RFC7525" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc7525"><front><title>Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</title>
<author fullname="Y. Sheffer" initials="Y." surname="Sheffer"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="R. Holz" initials="R." surname="Holz"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="P. Saint-Andre" initials="P." surname="Saint-Andre"><organization showOnFrontPage="true"></organization>
</author>
<date month="May" year="2015"></date>
<abstract><t>Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) are widely used to protect data exchanged over application protocols such as HTTP, SMTP, IMAP, POP, SIP, and XMPP.  Over the last few years, several serious attacks on TLS have emerged, including attacks on its most commonly used cipher suites and their modes of operation.  This document provides recommendations for improving the security of deployed services that use TLS and DTLS. The recommendations are applicable to the majority of use cases.</t>
</abstract>
</front>
<seriesInfo name="BCP" value="195"></seriesInfo>
<seriesInfo name="RFC" value="7525"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC7525"></seriesInfo>
</reference>
<reference anchor="RFC7915" derivedAnchor="RFC7915" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc7915"><front><title>IP/ICMP Translation Algorithm</title>
<author fullname="C. Bao" initials="C." surname="Bao"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="X. Li" initials="X." surname="Li"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="F. Baker" initials="F." surname="Baker"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="T. Anderson" initials="T." surname="Anderson"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="F. Gont" initials="F." surname="Gont"><organization showOnFrontPage="true"></organization>
</author>
<date month="June" year="2016"></date>
<abstract><t>This document describes the Stateless IP/ICMP Translation Algorithm (SIIT), which translates between IPv4 and IPv6 packet headers (including ICMP headers).  This document obsoletes RFC 6145.</t>
</abstract>
</front>
<seriesInfo name="RFC" value="7915"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC7915"></seriesInfo>
</reference>
<reference anchor="RFC7982" derivedAnchor="RFC7982" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc7982"><front><title>Measurement of Round-Trip Time and Fractional Loss Using Session Traversal Utilities for NAT (STUN)</title>
<author fullname="P. Martinsen" initials="P." surname="Martinsen"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="T. Reddy" initials="T." surname="Reddy"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="D. Wing" initials="D." surname="Wing"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="V. Singh" initials="V." surname="Singh"><organization showOnFrontPage="true"></organization>
</author>
<date month="September" year="2016"></date>
<abstract><t>A host with multiple interfaces needs to choose the best interface for communication.  Oftentimes, this decision is based on a static configuration and does not consider the path characteristics, which may affect the user experience.</t>
<t>This document describes a mechanism for an endpoint to measure the path characteristics fractional loss and RTT using Session Traversal Utilities for NAT (STUN) messages.</t>
</abstract>
</front>
<seriesInfo name="RFC" value="7982"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC7982"></seriesInfo>
</reference>
<reference anchor="RFC8174" derivedAnchor="RFC8174" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc8174"><front><title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author fullname="B. Leiba" initials="B." surname="Leiba"><organization showOnFrontPage="true"></organization>
</author>
<date month="May" year="2017"></date>
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
</abstract>
</front>
<seriesInfo name="BCP" value="14"></seriesInfo>
<seriesInfo name="RFC" value="8174"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC8174"></seriesInfo>
</reference>
<reference anchor="RFC8200" derivedAnchor="RFC8200" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc8200"><front><title>Internet Protocol, Version 6 (IPv6) Specification</title>
<author fullname="S. Deering" initials="S." surname="Deering"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="R. Hinden" initials="R." surname="Hinden"><organization showOnFrontPage="true"></organization>
</author>
<date month="July" year="2017"></date>
<abstract><t>This document specifies version 6 of the Internet Protocol (IPv6). It obsoletes RFC 2460.</t>
</abstract>
</front>
<seriesInfo name="STD" value="86"></seriesInfo>
<seriesInfo name="RFC" value="8200"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC8200"></seriesInfo>
</reference>
<reference anchor="RFC8305" derivedAnchor="RFC8305" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc8305"><front><title>Happy Eyeballs Version 2: Better Connectivity Using Concurrency</title>
<author fullname="D. Schinazi" initials="D." surname="Schinazi"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="T. Pauly" initials="T." surname="Pauly"><organization showOnFrontPage="true"></organization>
</author>
<date month="December" year="2017"></date>
<abstract><t>Many communication protocols operating over the modern Internet use hostnames.  These often resolve to multiple IP addresses, each of which may have different performance and connectivity characteristics.  Since specific addresses or address families (IPv4 or IPv6) may be blocked, broken, or sub-optimal on a network, clients that attempt multiple connections in parallel have a chance of establishing a connection more quickly.  This document specifies requirements for algorithms that reduce this user-visible delay and provides an example algorithm, referred to as "Happy Eyeballs".  This document obsoletes the original algorithm description in RFC 6555.</t>
</abstract>
</front>
<seriesInfo name="RFC" value="8305"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC8305"></seriesInfo>
</reference>
<reference anchor="RFC8446" derivedAnchor="RFC8446" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc8446"><front><title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
<author fullname="E. Rescorla" initials="E." surname="Rescorla"><organization showOnFrontPage="true"></organization>
</author>
<date month="August" year="2018"></date>
<abstract><t>This document specifies version 1.3 of the Transport Layer Security (TLS) protocol.  TLS allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</t>
<t>This document updates RFCs 5705 and 6066, and obsoletes RFCs 5077, 5246, and 6961.  This document also specifies new requirements for TLS 1.2 implementations.</t>
</abstract>
</front>
<seriesInfo name="RFC" value="8446"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC8446"></seriesInfo>
</reference>
<reference anchor="RFC8489" derivedAnchor="RFC8489" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc8489"><front><title>Session Traversal Utilities for NAT (STUN)</title>
<seriesInfo name="RFC" value="8489"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC8489"></seriesInfo>
<author fullname="Marc Petit-Huguenin" initials="M" surname="Petit-Huguenin"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="Gonzalo Salgueiro" initials="G" surname="Salgueiro"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="Jonathan Rosenberg" initials="J" surname="Rosenberg"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="Dan Wing" initials="D" surname="Wing"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="Rohan Mahy" initials="R" surname="Mahy"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="Philip Matthews" initials="P" surname="Matthews"><organization showOnFrontPage="true"></organization>
</author>
<date month="February" year="2020"></date>
</front>
</reference>
++++

[bibliography]
== Informative References
++++
<reference anchor="I-D.ietf-intarea-frag-fragile" derivedAnchor="FRAG-FRAGILE" quoteTitle="true" target="https://tools.ietf.org/html/draft-ietf-intarea-frag-fragile-17"><front><title>IP Fragmentation Considered Fragile</title>
<author fullname="Ron Bonica" initials="R" surname="Bonica"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="Fred Baker" initials="F" surname="Baker"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="Geoff Huston" initials="G" surname="Huston"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="Robert Hinden" initials="R" surname="Hinden"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="Ole Troan" initials="O" surname="Troan"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="Fernando Gont" initials="F" surname="Gont"><organization showOnFrontPage="true"></organization>
</author>
<date day="30" month="September" year="2019"></date>
<abstract><t>This document describes IP fragmentation and explains how it introduces fragility to Internet communication.  This document also proposes alternatives to IP fragmentation and provides recommendations for developers and network operators.</t>
</abstract>
</front>
<seriesInfo name="Internet-Draft" value="draft-ietf-intarea-frag-fragile-17"></seriesInfo>
<format target="http://www.ietf.org/internet-drafts/draft-ietf-intarea-frag-fragile-17.txt" type="TXT"></format>
<refcontent>Work in Progress</refcontent>
</reference>
<reference anchor="FRAG-HARMFUL" derivedAnchor="FRAG-HARMFUL" quoteTitle="true" target="https://www.hpl.hp.com/techreports/Compaq-DEC/WRL-87-3.pdf"><front><title>Fragmentation Considered Harmful</title>
<author fullname="Kent" initials="C." surname="Kent"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="Mogul" initials="J." surname="Mogul"><organization showOnFrontPage="true"></organization>
</author>
<date month="December" year="1987"></date>
</front>
</reference>
<reference anchor="I-D.ietf-tsvwg-datagram-plpmtud" derivedAnchor="MTU-DATAGRAM" quoteTitle="true" target="https://tools.ietf.org/html/draft-ietf-tsvwg-datagram-plpmtud-14"><front><title>Packetization Layer Path MTU Discovery for Datagram Transports</title>
<author fullname="Gorry Fairhurst" initials="G" surname="Fairhurst"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="Tom Jones" initials="T" surname="Jones"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="Michael Tuexen" initials="M" surname="Tuexen"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="Irene Ruengeler" initials="I" surname="Ruengeler"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="Timo Voelker" initials="T" surname="Voelker"><organization showOnFrontPage="true"></organization>
</author>
<date day="12" month="February" year="2020"></date>
<abstract><t>This document describes a robust method for Path MTU Discovery (PMTUD) for datagram Packetization Layers (PLs).  It describes an extension to RFC 1191 and RFC 8201, which specifies ICMP-based Path MTU Discovery for IPv4 and IPv6.  The method allows a PL, or a datagram application that uses a PL, to discover whether a network path can support the current size of datagram.  This can be used to detect and reduce the message size when a sender encounters a packet black hole (where packets are discarded).  The method can probe a network path with progressively larger packets to discover whether the maximum packet size can be increased.  This allows a sender to determine an appropriate packet size, providing functionality for datagram transports that is equivalent to the Packetization Layer PMTUD specification for TCP, specified in RFC 4821.  The document updates RFC 4821 to specify the method for datagram PLs, and updates RFC 8085 as the method to use in place of RFC 4821 with UDP datagrams.  Section 7.3 of RFC4960 recommends an endpoint apply the techniques in RFC4821 on a per-destination-address basis. RFC4960 is updated to recommend that SCTP uses the method specified in this document instead of the method in RFC4821.  The document also provides implementation notes for incorporating Datagram PMTUD into IETF datagram transports or applications that use datagram transports.  When published, this specification updates RFC 4821 and RFC 8085.</t>
</abstract>
</front>
<seriesInfo name="Internet-Draft" value="draft-ietf-tsvwg-datagram-plpmtud-14"></seriesInfo>
<format target="http://www.ietf.org/internet-drafts/draft-ietf-tsvwg-datagram-plpmtud-14.txt" type="TXT"></format>
<refcontent>Work in Progress</refcontent>
</reference>
<reference anchor="I-D.ietf-tram-stun-pmtud" derivedAnchor="MTU-STUN" quoteTitle="true" target="https://tools.ietf.org/html/draft-ietf-tram-stun-pmtud-15"><front><title>Packetization Layer Path MTU Discovery (PLMTUD) For UDP Transports Using Session Traversal Utilities for NAT (STUN)</title>
<author fullname="Marc Petit-Huguenin" initials="M" surname="Petit-Huguenin"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="Gonzalo Salgueiro" initials="G" surname="Salgueiro"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="Felipe Garrido" initials="F" surname="Garrido"><organization showOnFrontPage="true"></organization>
</author>
<date day="17" month="December" year="2019"></date>
<abstract><t>The datagram exchanged between two Internet endpoints have to go through a series of physical and virtual links that may have different limits on the upper size of the datagram they can transmit without fragmentation.  Because fragmentation is considered harmful, most transports and protocols are designed with a mechanism that permits dynamic measurement of the maximum size of a datagram.  This mechanism is called Packetization Layer Path MTU Discovery (PLPMTUD). But the UDP transport and some of the protocols that use UDP were designed without that feature.  The Session Traversal Utilities for NAT (STUN) Usage described in this document permits retrofitting an existing UDP-based protocol with such a feature.  Similarly, a new UDP-based protocol could simply reuse the mechanism described in this document.</t>
</abstract>
</front>
<seriesInfo name="Internet-Draft" value="draft-ietf-tram-stun-pmtud-15"></seriesInfo>
<format target="http://www.ietf.org/internet-drafts/draft-ietf-tram-stun-pmtud-15.txt" type="TXT"></format>
<refcontent>Work in Progress</refcontent>
</reference>
<reference anchor="PORT-NUMBERS" derivedAnchor="PORT-NUMBERS" quoteTitle="true" target="https://www.iana.org/assignments/port-numbers"><front><title>Service Name and Transport Protocol Port Number Registry</title>
<author><organization showOnFrontPage="true">IANA</organization>
</author>
<date></date>
</front>
</reference>
<reference anchor="RFC0791" derivedAnchor="RFC0791" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc791"><front><title>Internet Protocol</title>
<author fullname="J. Postel" initials="J." surname="Postel"><organization showOnFrontPage="true"></organization>
</author>
<date month="September" year="1981"></date>
</front>
<seriesInfo name="STD" value="5"></seriesInfo>
<seriesInfo name="RFC" value="791"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC0791"></seriesInfo>
</reference>
<reference anchor="RFC1191" derivedAnchor="RFC1191" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc1191"><front><title>Path MTU discovery</title>
<author fullname="J.C. Mogul" initials="J.C." surname="Mogul"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="S.E. Deering" initials="S.E." surname="Deering"><organization showOnFrontPage="true"></organization>
</author>
<date month="November" year="1990"></date>
<abstract><t>This memo describes a technique for dynamically discovering the maximum transmission unit (MTU) of an arbitrary internet path.  It specifies a small change to the way routers generate one type of ICMP message.  For a path that passes through a router that has not been so changed, this technique might not discover the correct Path MTU, but it will always choose a Path MTU as accurate as, and in many cases more accurate than, the Path MTU that would be chosen by current practice.  [STANDARDS-TRACK]</t>
</abstract>
</front>
<seriesInfo name="RFC" value="1191"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC1191"></seriesInfo>
</reference>
<reference anchor="RFC1918" derivedAnchor="RFC1918" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc1918"><front><title>Address Allocation for Private Internets</title>
<author fullname="Y. Rekhter" initials="Y." surname="Rekhter"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="B. Moskowitz" initials="B." surname="Moskowitz"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="D. Karrenberg" initials="D." surname="Karrenberg"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="G. J. de Groot" initials="G. J." surname="de Groot"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="E. Lear" initials="E." surname="Lear"><organization showOnFrontPage="true"></organization>
</author>
<date month="February" year="1996"></date>
<abstract><t>This document describes address allocation for private internets.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
</abstract>
</front>
<seriesInfo name="BCP" value="5"></seriesInfo>
<seriesInfo name="RFC" value="1918"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC1918"></seriesInfo>
</reference>
<reference anchor="RFC1928" derivedAnchor="RFC1928" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc1928"><front><title>SOCKS Protocol Version 5</title>
<author fullname="M. Leech" initials="M." surname="Leech"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="M. Ganis" initials="M." surname="Ganis"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="Y. Lee" initials="Y." surname="Lee"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="R. Kuris" initials="R." surname="Kuris"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="D. Koblas" initials="D." surname="Koblas"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="L. Jones" initials="L." surname="Jones"><organization showOnFrontPage="true"></organization>
</author>
<date month="March" year="1996"></date>
<abstract><t>This memo describes a protocol that is an evolution of the previous version of the protocol, version 4 [1]. This new protocol stems from active discussions and prototype implementations.  [STANDARDS-TRACK]</t>
</abstract>
</front>
<seriesInfo name="RFC" value="1928"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC1928"></seriesInfo>
</reference>
<reference anchor="RFC3261" derivedAnchor="RFC3261" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc3261"><front><title>SIP: Session Initiation Protocol</title>
<author fullname="J. Rosenberg" initials="J." surname="Rosenberg"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="H. Schulzrinne" initials="H." surname="Schulzrinne"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="G. Camarillo" initials="G." surname="Camarillo"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="A. Johnston" initials="A." surname="Johnston"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="J. Peterson" initials="J." surname="Peterson"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="R. Sparks" initials="R." surname="Sparks"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="M. Handley" initials="M." surname="Handley"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="E. Schooler" initials="E." surname="Schooler"><organization showOnFrontPage="true"></organization>
</author>
<date month="June" year="2002"></date>
<abstract><t>This document describes Session Initiation Protocol (SIP), an application-layer control (signaling) protocol for creating, modifying, and terminating sessions with one or more participants.  These sessions include Internet telephone calls, multimedia distribution, and multimedia conferences.  [STANDARDS-TRACK]</t>
</abstract>
</front>
<seriesInfo name="RFC" value="3261"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC3261"></seriesInfo>
</reference>
<reference anchor="RFC3424" derivedAnchor="RFC3424" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc3424"><front><title>IAB Considerations for UNilateral Self-Address Fixing (UNSAF) Across Network Address Translation</title>
<author fullname="L. Daigle" initials="L." role="editor" surname="Daigle"><organization showOnFrontPage="true"></organization>
</author>
<author><organization showOnFrontPage="true">IAB</organization>
</author>
<date month="November" year="2002"></date>
<abstract><t>As a result of the nature of Network Address Translation (NAT) Middleboxes, communicating endpoints that are separated by one or more NATs do not know how to refer to themselves using addresses that are valid in the addressing realms of their (current and future) peers. Various proposals have been made for "UNilateral Self-Address Fixing (UNSAF)" processes.  These are processes whereby some originating endpoint attempts to determine or fix the address (and port) by which it is known to another endpoint - e.g., to be able to use address data in the protocol exchange, or to advertise a public address from which it will receive connections. This document outlines the reasons for which these proposals can be considered at best as short term fixes to specific problems and the specific issues to be carefully evaluated before creating an UNSAF proposal.  This memo provides information for the Internet community.</t>
</abstract>
</front>
<seriesInfo name="RFC" value="3424"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC3424"></seriesInfo>
</reference>
<reference anchor="RFC3550" derivedAnchor="RFC3550" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc3550"><front><title>RTP: A Transport Protocol for Real-Time Applications</title>
<author fullname="H. Schulzrinne" initials="H." surname="Schulzrinne"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="S. Casner" initials="S." surname="Casner"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="R. Frederick" initials="R." surname="Frederick"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="V. Jacobson" initials="V." surname="Jacobson"><organization showOnFrontPage="true"></organization>
</author>
<date month="July" year="2003"></date>
<abstract><t>This memorandum describes RTP, the real-time transport protocol.  RTP provides end-to-end network transport functions suitable for applications transmitting real-time data, such as audio, video or simulation data, over multicast or unicast network services.  RTP does not address resource reservation and does not guarantee quality-of- service for real-time services.  The data transport is augmented by a control protocol (RTCP) to allow monitoring of the data delivery in a manner scalable to large multicast networks, and to provide minimal control and identification functionality.  RTP and RTCP are designed to be independent of the underlying transport and network layers.  The protocol supports the use of RTP-level translators and mixers. Most of the text in this memorandum is identical to RFC 1889 which it obsoletes.  There are no changes in the packet formats on the wire, only changes to the rules and algorithms governing how the protocol is used. The biggest change is an enhancement to the scalable timer algorithm for calculating when to send RTCP packets in order to minimize transmission in excess of the intended rate when many participants join a session simultaneously.  [STANDARDS-TRACK]</t>
</abstract>
</front>
<seriesInfo name="STD" value="64"></seriesInfo>
<seriesInfo name="RFC" value="3550"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC3550"></seriesInfo>
</reference>
<reference anchor="RFC3711" derivedAnchor="RFC3711" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc3711"><front><title>The Secure Real-time Transport Protocol (SRTP)</title>
<author fullname="M. Baugher" initials="M." surname="Baugher"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="D. McGrew" initials="D." surname="McGrew"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="M. Naslund" initials="M." surname="Naslund"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="E. Carrara" initials="E." surname="Carrara"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="K. Norrman" initials="K." surname="Norrman"><organization showOnFrontPage="true"></organization>
</author>
<date month="March" year="2004"></date>
<abstract><t>This document describes the Secure Real-time Transport Protocol (SRTP), a profile of the Real-time Transport Protocol (RTP), which can provide confidentiality, message authentication, and replay protection to the RTP traffic and to the control traffic for RTP, the Real-time Transport Control Protocol (RTCP).   [STANDARDS-TRACK]</t>
</abstract>
</front>
<seriesInfo name="RFC" value="3711"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC3711"></seriesInfo>
</reference>
<reference anchor="RFC4086" derivedAnchor="RFC4086" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc4086"><front><title>Randomness Requirements for Security</title>
<author fullname="D. Eastlake 3rd" initials="D." surname="Eastlake 3rd"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="J. Schiller" initials="J." surname="Schiller"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="S. Crocker" initials="S." surname="Crocker"><organization showOnFrontPage="true"></organization>
</author>
<date month="June" year="2005"></date>
<abstract><t>Security systems are built on strong cryptographic algorithms that foil pattern analysis attempts.  However, the security of these systems is dependent on generating secret quantities for passwords, cryptographic keys, and similar quantities.  The use of pseudo-random processes to generate secret quantities can result in pseudo-security. A sophisticated attacker may find it easier to reproduce the environment that produced the secret quantities and to search the resulting small set of possibilities than to locate the quantities in the whole of the potential number space.</t>
<t>Choosing random quantities to foil a resourceful and motivated adversary is surprisingly difficult.  This document points out many pitfalls in using poor entropy sources or traditional pseudo-random number generation techniques for generating such quantities.  It recommends the use of truly random hardware techniques and shows that the existing hardware on many systems can be used for this purpose. It provides suggestions to ameliorate the problem when a hardware solution is not available, and it gives examples of how large such quantities need to be for some applications.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
</abstract>
</front>
<seriesInfo name="BCP" value="106"></seriesInfo>
<seriesInfo name="RFC" value="4086"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC4086"></seriesInfo>
</reference>
<reference anchor="RFC4302" derivedAnchor="RFC4302" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc4302"><front><title>IP Authentication Header</title>
<author fullname="S. Kent" initials="S." surname="Kent"><organization showOnFrontPage="true"></organization>
</author>
<date month="December" year="2005"></date>
<abstract><t>This document describes an updated version of the IP Authentication Header (AH), which is designed to provide authentication services in IPv4 and IPv6.  This document obsoletes RFC 2402 (November 1998).  [STANDARDS-TRACK]</t>
</abstract>
</front>
<seriesInfo name="RFC" value="4302"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC4302"></seriesInfo>
</reference>
<reference anchor="RFC4303" derivedAnchor="RFC4303" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc4303"><front><title>IP Encapsulating Security Payload (ESP)</title>
<author fullname="S. Kent" initials="S." surname="Kent"><organization showOnFrontPage="true"></organization>
</author>
<date month="December" year="2005"></date>
<abstract><t>This document describes an updated version of the Encapsulating Security Payload (ESP) protocol, which is designed to provide a mix of security services in IPv4 and IPv6.  ESP is used to provide confidentiality, data origin authentication, connectionless integrity, an anti-replay service (a form of partial sequence integrity), and limited traffic flow confidentiality.  This document obsoletes RFC 2406 (November 1998).  [STANDARDS-TRACK]</t>
</abstract>
</front>
<seriesInfo name="RFC" value="4303"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC4303"></seriesInfo>
</reference>
<reference anchor="RFC4787" derivedAnchor="RFC4787" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc4787"><front><title>Network Address Translation (NAT) Behavioral Requirements for Unicast UDP</title>
<author fullname="F. Audet" initials="F." role="editor" surname="Audet"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="C. Jennings" initials="C." surname="Jennings"><organization showOnFrontPage="true"></organization>
</author>
<date month="January" year="2007"></date>
<abstract><t>This document defines basic terminology for describing different types of Network Address Translation (NAT) behavior when handling Unicast UDP and also defines a set of requirements that would allow many applications, such as multimedia communications or online gaming, to work consistently.  Developing NATs that meet this set of requirements will greatly increase the likelihood that these applications will function properly.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
</abstract>
</front>
<seriesInfo name="BCP" value="127"></seriesInfo>
<seriesInfo name="RFC" value="4787"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC4787"></seriesInfo>
</reference>
<reference anchor="RFC4821" derivedAnchor="RFC4821" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc4821"><front><title>Packetization Layer Path MTU Discovery</title>
<author fullname="M. Mathis" initials="M." surname="Mathis"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="J. Heffner" initials="J." surname="Heffner"><organization showOnFrontPage="true"></organization>
</author>
<date month="March" year="2007"></date>
<abstract><t>This document describes a robust method for Path MTU Discovery (PMTUD) that relies on TCP or some other Packetization Layer to probe an Internet path with progressively larger packets.  This method is described as an extension to RFC 1191 and RFC 1981, which specify ICMP-based Path MTU Discovery for IP versions 4 and 6, respectively.  [STANDARDS-TRACK]</t>
</abstract>
</front>
<seriesInfo name="RFC" value="4821"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC4821"></seriesInfo>
</reference>
<reference anchor="RFC5128" derivedAnchor="RFC5128" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc5128"><front><title>State of Peer-to-Peer (P2P) Communication across Network Address Translators (NATs)</title>
<author fullname="P. Srisuresh" initials="P." surname="Srisuresh"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="B. Ford" initials="B." surname="Ford"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="D. Kegel" initials="D." surname="Kegel"><organization showOnFrontPage="true"></organization>
</author>
<date month="March" year="2008"></date>
<abstract><t>This memo documents the various methods known to be in use by applications to establish direct communication in the presence of Network Address Translators (NATs) at the current time.  Although this memo is intended to be mainly descriptive, the Security Considerations section makes some purely advisory recommendations about how to deal with security vulnerabilities the applications could inadvertently create when using the methods described.  This memo covers NAT traversal approaches used by both TCP- and UDP-based applications.  This memo is not an endorsement of the methods described, but merely an attempt to capture them in a document.  This memo provides information for the Internet community.</t>
</abstract>
</front>
<seriesInfo name="RFC" value="5128"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC5128"></seriesInfo>
</reference>
<reference anchor="RFC5482" derivedAnchor="RFC5482" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc5482"><front><title>TCP User Timeout Option</title>
<author fullname="L. Eggert" initials="L." surname="Eggert"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="F. Gont" initials="F." surname="Gont"><organization showOnFrontPage="true"></organization>
</author>
<date month="March" year="2009"></date>
<abstract><t>The TCP user timeout controls how long transmitted data may remain unacknowledged before a connection is forcefully closed.  It is a local, per-connection parameter.  This document specifies a new TCP option -- the TCP User Timeout Option -- that allows one end of a TCP connection to advertise its current user timeout value.  This information provides advice to the other end of the TCP connection to adapt its user timeout accordingly.  Increasing the user timeouts on both ends of a TCP connection allows it to survive extended periods without end-to-end connectivity.  Decreasing the user timeouts allows busy servers to explicitly notify their clients that they will maintain the connection state only for a short time without connectivity.  [STANDARDS-TRACK]</t>
</abstract>
</front>
<seriesInfo name="RFC" value="5482"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC5482"></seriesInfo>
</reference>
<reference anchor="RFC5766" derivedAnchor="RFC5766" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc5766"><front><title>Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)</title>
<author fullname="R. Mahy" initials="R." surname="Mahy"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="P. Matthews" initials="P." surname="Matthews"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="J. Rosenberg" initials="J." surname="Rosenberg"><organization showOnFrontPage="true"></organization>
</author>
<date month="April" year="2010"></date>
<abstract><t>If a host is located behind a NAT, then in certain situations it can be impossible for that host to communicate directly with other hosts (peers).  In these situations, it is necessary for the host to use the services of an intermediate node that acts as a communication relay.  This specification defines a protocol, called TURN (Traversal Using Relays around NAT), that allows the host to control the operation of the relay and to exchange packets with its peers using the relay.  TURN differs from some other relay control protocols in that it allows a client to communicate with multiple peers using a single relay address.  [STANDARDS-TRACK]</t>
</abstract>
</front>
<seriesInfo name="RFC" value="5766"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC5766"></seriesInfo>
</reference>
<reference anchor="RFC5925" derivedAnchor="RFC5925" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc5925"><front><title>The TCP Authentication Option</title>
<author fullname="J. Touch" initials="J." surname="Touch"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="A. Mankin" initials="A." surname="Mankin"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="R. Bonica" initials="R." surname="Bonica"><organization showOnFrontPage="true"></organization>
</author>
<date month="June" year="2010"></date>
<abstract><t>This document specifies the TCP Authentication Option (TCP-AO), which obsoletes the TCP MD5 Signature option of RFC 2385 (TCP MD5).  TCP-AO specifies the use of stronger Message Authentication Codes (MACs), protects against replays even for long-lived TCP connections, and provides more details on the association of security with TCP connections than TCP MD5.  TCP-AO is compatible with either a static Master Key Tuple (MKT) configuration or an external, out-of-band MKT management mechanism; in either case, TCP-AO also protects connections when using the same MKT across repeated instances of a connection, using traffic keys derived from the MKT, and coordinates MKT changes between endpoints.  The result is intended to support current infrastructure uses of TCP MD5, such as to protect long-lived connections (as used, e.g., in BGP and LDP), and to support a larger set of MACs with minimal other system and operational changes.  TCP-AO uses a different option identifier than TCP MD5, even though TCP-AO and TCP MD5 are never permitted to be used simultaneously.  TCP-AO supports IPv6, and is fully compatible with the proposed requirements for the replacement of TCP MD5.  [STANDARDS-TRACK]</t>
</abstract>
</front>
<seriesInfo name="RFC" value="5925"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC5925"></seriesInfo>
</reference>
<reference anchor="RFC5928" derivedAnchor="RFC5928" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc5928"><front><title>Traversal Using Relays around NAT (TURN) Resolution Mechanism</title>
<author fullname="M. Petit-Huguenin" initials="M." surname="Petit-Huguenin"><organization showOnFrontPage="true"></organization>
</author>
<date month="August" year="2010"></date>
<abstract><t>This document defines a resolution mechanism to generate a list of server transport addresses that can be tried to create a Traversal Using Relays around NAT (TURN) allocation.  [STANDARDS-TRACK]</t>
</abstract>
</front>
<seriesInfo name="RFC" value="5928"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC5928"></seriesInfo>
</reference>
<reference anchor="RFC6056" derivedAnchor="RFC6056" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc6056"><front><title>Recommendations for Transport-Protocol Port Randomization</title>
<author fullname="M. Larsen" initials="M." surname="Larsen"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="F. Gont" initials="F." surname="Gont"><organization showOnFrontPage="true"></organization>
</author>
<date month="January" year="2011"></date>
<abstract><t>During the last few years, awareness has been raised about a number of "blind" attacks that can be performed against the Transmission Control Protocol (TCP) and similar protocols.  The consequences of these attacks range from throughput reduction to broken connections or data corruption.  These attacks rely on the attacker's ability to guess or know the five-tuple (Protocol, Source Address, Destination Address, Source Port, Destination Port) that identifies the transport protocol instance to be attacked.  This document describes a number of simple and efficient methods for the selection of the client port number, such that the possibility of an attacker guessing the exact value is reduced.  While this is not a replacement for cryptographic methods for protecting the transport-protocol instance, the aforementioned port selection algorithms provide improved security with very little effort and without any key management overhead.  The algorithms described in this document are local policies that may be incrementally deployed and that do not violate the specifications of any of the transport protocols that may benefit from them, such as TCP, UDP, UDP-lite, Stream Control Transmission Protocol (SCTP), Datagram Congestion Control Protocol (DCCP), and RTP (provided that the RTP application explicitly signals the RTP and RTCP port numbers).  This memo documents an Internet Best Current Practice.</t>
</abstract>
</front>
<seriesInfo name="BCP" value="156"></seriesInfo>
<seriesInfo name="RFC" value="6056"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC6056"></seriesInfo>
</reference>
<reference anchor="RFC6062" derivedAnchor="RFC6062" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc6062"><front><title>Traversal Using Relays around NAT (TURN) Extensions for TCP Allocations</title>
<author fullname="S. Perreault" initials="S." role="editor" surname="Perreault"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="J. Rosenberg" initials="J." surname="Rosenberg"><organization showOnFrontPage="true"></organization>
</author>
<date month="November" year="2010"></date>
<abstract><t>This specification defines an extension of Traversal Using Relays around NAT (TURN), a relay protocol for Network Address Translator (NAT) traversal.  This extension allows a TURN client to request TCP allocations, and defines new requests and indications for the TURN server to open and accept TCP connections with the client\'s peers. TURN and this extension both purposefully restrict the ways in which the relayed address can be used.  In particular, it prevents users from running general-purpose servers from ports obtained from the TURN server.  [STANDARDS-TRACK]</t>
</abstract>
</front>
<seriesInfo name="RFC" value="6062"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC6062"></seriesInfo>
</reference>
<reference anchor="RFC6156" derivedAnchor="RFC6156" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc6156"><front><title>Traversal Using Relays around NAT (TURN) Extension for IPv6</title>
<author fullname="G. Camarillo" initials="G." surname="Camarillo"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="O. Novo" initials="O." surname="Novo"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="S. Perreault" initials="S." role="editor" surname="Perreault"><organization showOnFrontPage="true"></organization>
</author>
<date month="April" year="2011"></date>
<abstract><t>This document adds IPv6 support to Traversal Using Relays around NAT (TURN).  IPv6 support in TURN includes IPv4-to-IPv6, IPv6-to-IPv6, and IPv6-to-IPv4 relaying.  This document defines the REQUESTED- ADDRESS-FAMILY attribute for TURN.  The REQUESTED-ADDRESS-FAMILY attribute allows a client to explicitly request the address type the TURN server will allocate (e.g., an IPv4-only node may request the TURN server to allocate an IPv6 address).  [STANDARDS-TRACK]</t>
</abstract>
</front>
<seriesInfo name="RFC" value="6156"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC6156"></seriesInfo>
</reference>
<reference anchor="RFC6263" derivedAnchor="RFC6263" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc6263"><front><title>Application Mechanism for Keeping Alive the NAT Mappings Associated with RTP / RTP Control Protocol (RTCP) Flows</title>
<author fullname="X. Marjou" initials="X." surname="Marjou"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="A. Sollaud" initials="A." surname="Sollaud"><organization showOnFrontPage="true"></organization>
</author>
<date month="June" year="2011"></date>
<abstract><t>This document lists the different mechanisms that enable applications using the Real-time Transport Protocol (RTP) and the RTP Control Protocol (RTCP) to keep their RTP Network Address Translator (NAT) mappings alive.  It also makes a recommendation for a preferred mechanism.  This document is not applicable to Interactive Connectivity Establishment (ICE) agents.  [STANDARDS-TRACK]</t>
</abstract>
</front>
<seriesInfo name="RFC" value="6263"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC6263"></seriesInfo>
</reference>
<reference anchor="RFC7413" derivedAnchor="RFC7413" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc7413"><front><title>TCP Fast Open</title>
<author fullname="Y. Cheng" initials="Y." surname="Cheng"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="J. Chu" initials="J." surname="Chu"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="S. Radhakrishnan" initials="S." surname="Radhakrishnan"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="A. Jain" initials="A." surname="Jain"><organization showOnFrontPage="true"></organization>
</author>
<date month="December" year="2014"></date>
<abstract><t>This document describes an experimental TCP mechanism called TCP Fast Open (TFO).  TFO allows data to be carried in the SYN and SYN-ACK packets and consumed by the receiving end during the initial connection handshake, and saves up to one full round-trip time (RTT) compared to the standard TCP, which requires a three-way handshake (3WHS) to complete before data can be exchanged.  However, TFO deviates from the standard TCP semantics, since the data in the SYN could be replayed to an application in some rare circumstances.  Applications should not use TFO unless they can tolerate this issue, as detailed in the Applicability section.</t>
</abstract>
</front>
<seriesInfo name="RFC" value="7413"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC7413"></seriesInfo>
</reference>
<reference anchor="RFC7478" derivedAnchor="RFC7478" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc7478"><front><title>Web Real-Time Communication Use Cases and Requirements</title>
<author fullname="C. Holmberg" initials="C." surname="Holmberg"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="S. Hakansson" initials="S." surname="Hakansson"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="G. Eriksson" initials="G." surname="Eriksson"><organization showOnFrontPage="true"></organization>
</author>
<date month="March" year="2015"></date>
<abstract><t>This document describes web-based real-time communication use cases. Requirements on the browser functionality are derived from the use cases.</t>
<t>This document was developed in an initial phase of the work with rather minor updates at later stages.  It has not really served as a tool in deciding features or scope for the WG's efforts so far.  It is being published to record the early conclusions of the WG.  It will not be used as a set of rigid guidelines that specifications and implementations will be held to in the future.</t>
</abstract>
</front>
<seriesInfo name="RFC" value="7478"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC7478"></seriesInfo>
</reference>
<reference anchor="RFC7635" derivedAnchor="RFC7635" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc7635"><front><title>Session Traversal Utilities for NAT (STUN) Extension for Third-Party Authorization</title>
<author fullname="T. Reddy" initials="T." surname="Reddy"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="P. Patil" initials="P." surname="Patil"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="R. Ravindranath" initials="R." surname="Ravindranath"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="J. Uberti" initials="J." surname="Uberti"><organization showOnFrontPage="true"></organization>
</author>
<date month="August" year="2015"></date>
<abstract><t>This document proposes the use of OAuth 2.0 to obtain and validate ephemeral tokens that can be used for Session Traversal Utilities for NAT (STUN) authentication.  The usage of ephemeral tokens ensures that access to a STUN server can be controlled even if the tokens are compromised.</t>
</abstract>
</front>
<seriesInfo name="RFC" value="7635"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC7635"></seriesInfo>
</reference>
<reference anchor="RFC7657" derivedAnchor="RFC7657" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc7657"><front><title>Differentiated Services (Diffserv) and Real-Time Communication</title>
<author fullname="D. Black" initials="D." role="editor" surname="Black"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="P. Jones" initials="P." surname="Jones"><organization showOnFrontPage="true"></organization>
</author>
<date month="November" year="2015"></date>
<abstract><t>This memo describes the interaction between Differentiated Services (Diffserv) network quality-of-service (QoS) functionality and real- time network communication, including communication based on the Real-time Transport Protocol (RTP).  Diffserv is based on network nodes applying different forwarding treatments to packets whose IP headers are marked with different Diffserv Codepoints (DSCPs). WebRTC applications, as well as some conferencing applications, have begun using the Session Description Protocol (SDP) bundle negotiation mechanism to send multiple traffic streams with different QoS requirements using the same network 5-tuple.  The results of using multiple DSCPs to obtain different QoS treatments within a single network 5-tuple have transport protocol interactions, particularly with congestion control functionality (e.g., reordering).  In addition, DSCP markings may be changed or removed between the traffic source and destination.  This memo covers the implications of these Diffserv aspects for real-time network communication, including WebRTC.</t>
</abstract>
</front>
<seriesInfo name="RFC" value="7657"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC7657"></seriesInfo>
</reference>
<reference anchor="RFC7983" derivedAnchor="RFC7983" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc7983"><front><title>Multiplexing Scheme Updates for Secure Real-time Transport Protocol (SRTP) Extension for Datagram Transport Layer Security (DTLS)</title>
<author fullname="M. Petit-Huguenin" initials="M." surname="Petit-Huguenin"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="G. Salgueiro" initials="G." surname="Salgueiro"><organization showOnFrontPage="true"></organization>
</author>
<date month="September" year="2016"></date>
<abstract><t>This document defines how Datagram Transport Layer Security (DTLS), Real-time Transport Protocol (RTP), RTP Control Protocol (RTCP), Session Traversal Utilities for NAT (STUN), Traversal Using Relays around NAT (TURN), and ZRTP packets are multiplexed on a single receiving socket.  It overrides the guidance from RFC 5764 ("SRTP                Extension for DTLS"), which suffered from four issues described and fixed in this document.</t>
<t>This document updates RFC 5764.</t>
</abstract>
</front>
<seriesInfo name="RFC" value="7983"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC7983"></seriesInfo>
</reference>
<reference anchor="RFC8155" derivedAnchor="RFC8155" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc8155"><front><title>Traversal Using Relays around NAT (TURN) Server Auto Discovery</title>
<author fullname="P. Patil" initials="P." surname="Patil"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="T. Reddy" initials="T." surname="Reddy"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="D. Wing" initials="D." surname="Wing"><organization showOnFrontPage="true"></organization>
</author>
<date month="April" year="2017"></date>
<abstract><t>Current Traversal Using Relays around NAT (TURN) server discovery mechanisms are relatively static and limited to explicit configuration.  These are usually under the administrative control of the application or TURN service provider, and not the enterprise, ISP, or the network in which the client is located.  Enterprises and ISPs wishing to provide their own TURN servers need auto-discovery mechanisms that a TURN client could use with minimal or no configuration.  This document describes three such mechanisms for TURN server discovery.</t>
<t>This document updates RFC 5766 to relax the requirement for mutual authentication in certain cases.</t>
</abstract>
</front>
<seriesInfo name="RFC" value="8155"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC8155"></seriesInfo>
</reference>
<reference anchor="RFC8311" derivedAnchor="RFC8311" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc8311"><front><title>Relaxing Restrictions on Explicit Congestion Notification (ECN) Experimentation</title>
<author fullname="D. Black" initials="D." surname="Black"><organization showOnFrontPage="true"></organization>
</author>
<date month="January" year="2018"></date>
<abstract><t>This memo updates RFC 3168, which specifies Explicit Congestion Notification (ECN) as an alternative to packet drops for indicating network congestion to endpoints.  It relaxes restrictions in RFC 3168 that hinder experimentation towards benefits beyond just removal of loss.  This memo summarizes the anticipated areas of experimentation and updates RFC 3168 to enable experimentation in these areas.  An Experimental RFC in the IETF document stream is required to take advantage of any of these enabling updates.  In addition, this memo makes related updates to the ECN specifications for RTP in RFC 6679 and for the Datagram Congestion Control Protocol (DCCP) in RFCs 4341, 4342, and 5622.  This memo also records the conclusion of the ECN nonce experiment in RFC 3540 and provides the rationale for reclassification of RFC 3540 from Experimental to Historic; this reclassification enables new experimental use of the ECT(1) codepoint.</t>
</abstract>
</front>
<seriesInfo name="RFC" value="8311"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC8311"></seriesInfo>
</reference>
<reference anchor="RFC8445" derivedAnchor="RFC8445" quoteTitle="true" target="https://www.rfc-editor.org/info/rfc8445"><front><title>Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal</title>
<author fullname="A. Keranen" initials="A." surname="Keranen"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="C. Holmberg" initials="C." surname="Holmberg"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="J. Rosenberg" initials="J." surname="Rosenberg"><organization showOnFrontPage="true"></organization>
</author>
<date month="July" year="2018"></date>
<abstract><t>This document describes a protocol for Network Address Translator (NAT) traversal for UDP-based communication.  This protocol is called Interactive Connectivity Establishment (ICE).  ICE makes use of the Session Traversal Utilities for NAT (STUN) protocol and its extension, Traversal Using Relay NAT (TURN).</t>
<t>This document obsoletes RFC 5245.</t>
</abstract>
</front>
<seriesInfo name="RFC" value="8445"></seriesInfo>
<seriesInfo name="DOI" value="10.17487/RFC8445"></seriesInfo>
</reference>
<reference anchor="I-D.ietf-mmusic-ice-sip-sdp" derivedAnchor="SDP-ICE" quoteTitle="true" target="https://tools.ietf.org/html/draft-ietf-mmusic-ice-sip-sdp-39"><front><title>Session Description Protocol (SDP) Offer/Answer procedures for Interactive Connectivity Establishment (ICE)</title>
<author fullname="Marc Petit-Huguenin" initials="M" surname="Petit-Huguenin"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="Suhas Nandakumar" initials="S" surname="Nandakumar"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="Christer Holmberg" initials="C" surname="Holmberg"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="Ari Keranen" initials="A" surname="Keranen"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="Roman Shpount" initials="R" surname="Shpount"><organization showOnFrontPage="true"></organization>
</author>
<date day="13" month="August" year="2019"></date>
<abstract><t>This document describes Session Description Protocol (SDP) Offer/ Answer procedures for carrying out Interactive Connectivity Establishment (ICE) between the agents.  This document obsoletes RFC 5245.</t>
</abstract>
</front>
<seriesInfo name="Internet-Draft" value="draft-ietf-mmusic-ice-sip-sdp-39"></seriesInfo>
<format target="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-ice-sip-sdp-39.txt" type="TXT"></format>
<refcontent>Work in Progress</refcontent>
</reference>
<reference anchor="I-D.ietf-rtcweb-security" derivedAnchor="SEC-WEBRTC" quoteTitle="true" target="https://tools.ietf.org/html/draft-ietf-rtcweb-security-12"><front><title>Security Considerations for WebRTC</title>
<author fullname="Eric Rescorla" initials="E" surname="Rescorla"><organization showOnFrontPage="true"></organization>
</author>
<date day="5" month="July" year="2019"></date>
<abstract><t>WebRTC is a protocol suite for use with real-time applications that can be deployed in browsers - "real time communication on the Web". This document defines the WebRTC threat model and analyzes the security threats of WebRTC in that model.</t>
</abstract>
</front>
<seriesInfo name="Internet-Draft" value="draft-ietf-rtcweb-security-12"></seriesInfo>
<format target="http://www.ietf.org/internet-drafts/draft-ietf-rtcweb-security-12.txt" type="TXT"></format>
<refcontent>Work in Progress</refcontent>
</reference>
<reference anchor="I-D.ietf-mptcp-rfc6824bis" derivedAnchor="TCP-EXT" quoteTitle="true" target="https://tools.ietf.org/html/draft-ietf-mptcp-rfc6824bis-18"><front><title>TCP Extensions for Multipath Operation with Multiple Addresses</title>
<author fullname="Alan Ford" initials="A" surname="Ford"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="Costin Raiciu" initials="C" surname="Raiciu"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="Mark Handley" initials="M" surname="Handley"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="Olivier Bonaventure" initials="O" surname="Bonaventure"><organization showOnFrontPage="true"></organization>
</author>
<author fullname="Christoph Paasch" initials="C" surname="Paasch"><organization showOnFrontPage="true"></organization>
</author>
<date day="8" month="June" year="2019"></date>
<abstract><t>TCP/IP communication is currently restricted to a single path per connection, yet multiple paths often exist between peers.  The simultaneous use of these multiple paths for a TCP/IP session would improve resource usage within the network and, thus, improve user experience through higher throughput and improved resilience to network failure.  Multipath TCP provides the ability to simultaneously use multiple paths between peers.  This document presents a set of extensions to traditional TCP to support multipath operation.  The protocol offers the same type of service to applications as TCP (i.e., reliable bytestream), and it provides the components necessary to establish and use multiple TCP flows across potentially disjoint paths.  This document specifies v1 of Multipath TCP, obsoleting v0 as specified in RFC6824, through clarifications and modifications primarily driven by deployment experience.</t>
</abstract>
</front>
<seriesInfo name="Internet-Draft" value="draft-ietf-mptcp-rfc6824bis-18"></seriesInfo>
<format target="http://www.ietf.org/internet-drafts/draft-ietf-mptcp-rfc6824bis-18.txt" type="TXT"></format>
<refcontent>Work in Progress</refcontent>
</reference>
<reference anchor="I-D.ietf-tsvwg-udp-options" derivedAnchor="UDP-OPT" quoteTitle="true" target="https://tools.ietf.org/html/draft-ietf-tsvwg-udp-options-08"><front><title>Transport Options for UDP</title>
<author fullname="Joseph Touch" initials="J" surname="Touch"><organization showOnFrontPage="true"></organization>
</author>
<date day="12" month="September" year="2019"></date>
<abstract><t>Transport protocols are extended through the use of transport header options. This document extends UDP by indicating the location, syntax, and semantics for UDP transport layer options.</t>
</abstract>
</front>
<seriesInfo name="Internet-Draft" value="draft-ietf-tsvwg-udp-options-08"></seriesInfo>
<format target="http://www.ietf.org/internet-drafts/draft-ietf-tsvwg-udp-options-08.txt" type="TXT"></format>
<refcontent>Work in Progress</refcontent>
</reference>
++++

[appendix,numbered=false,removeInRFC=false,toc=include]
== Acknowledgements

Most of the text in this note comes from the original TURN specification, <<RFC5766,format=default>>. The authors would like to thank Rohan Mahy, coauthor of the original TURN specification, and everyone who had contributed to that document. The authors would also like to acknowledge that this document inherits material from <<RFC6156,format=default>>.

Thanks to Justin Uberti, Pal       Martinsen, Oleg Moskalenko, Aijun Wang, and Simon Perreault for their help on the ADDITIONAL-ADDRESS-FAMILY mechanism. The authors would like to thank Gonzalo Salgueiro, Simon Perreault, Jonathan Lennox, Brandon Williams, Karl       Stahl, Noriyuki Torii, Nils       Ohlmeier, Dan Wing, Vijay       Gurbani, Joseph Touch, Justin Uberti, Christopher Wood, Roman Danyliw, Eric Vyncke, Adam Roach, Suresh Krishnan, Mirja Kuehlewind, Benjamin       Kaduk, and Oleg Moskalenko for comments and review. The authors would like to thank Marc Petit-Huguenin for his contributions to the text.

Special thanks to Magnus Westerlund for the detailed AD review.
